// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package opsgenie

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Manages a Notification Rule within Opsgenie.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-opsgenie/sdk/go/opsgenie"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		testUser, err := opsgenie.NewUser(ctx, "testUser", &opsgenie.UserArgs{
// 			Username: pulumi.String("Example user"),
// 			FullName: pulumi.String("Name Lastname"),
// 			Role:     pulumi.String("User"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = opsgenie.NewNotificationRule(ctx, "testNotificationRule", &opsgenie.NotificationRuleArgs{
// 			Username:   testUser.Username,
// 			ActionType: pulumi.String("schedule-end"),
// 			NotificationTimes: pulumi.StringArray{
// 				pulumi.String("just-before"),
// 				pulumi.String("15-minutes-ago"),
// 			},
// 			Steps: opsgenie.NotificationRuleStepArray{
// 				&opsgenie.NotificationRuleStepArgs{
// 					Contacts: opsgenie.NotificationRuleStepContactArray{
// 						&opsgenie.NotificationRuleStepContactArgs{
// 							Method: pulumi.String("email"),
// 							To:     pulumi.String("example@user.com"),
// 						},
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Notification policies can be imported using the `user id` and `id`, e.g.
//
// ```sh
//  $ pulumi import opsgenie:index/notificationRule:NotificationRule test userId/Id`
// ```
//
//  For this example- User Id = `c827c472-31f2-497b-9ec6-8ec855d7d94c`
//
// - Notification Rule Id = `2d1a78d0-c13e-47d3-af0a-8b6d0cc2b7b1`
//
// ```sh
//  $ pulumi import opsgenie:index/notificationRule:NotificationRule test c827c472-31f2-497b-9ec6-8ec855d7d94c/2d1a78d0-c13e-47d3-af0a-8b6d0cc2b7b1`
// ```
type NotificationRule struct {
	pulumi.CustomResourceState

	// Type of the action that notification rule will have. Allowed values: "create-alert", "acknowledged-alert", "closed-alert", "assigned-alert", "add-note", "schedule-start", "schedule-end", "incoming-call-routing"
	ActionType pulumi.StringOutput                 `pulumi:"actionType"`
	Criterias  NotificationRuleCriteriaArrayOutput `pulumi:"criterias"`
	// Defined if this step is enabled. Default: true
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// Name of the notification policy
	Name pulumi.StringOutput `pulumi:"name"`
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: "just-before", "15-minutes-ago", "1-hour-ago", "1-day-ago". If `actionType` is "schedule-start" or "schedule-end" then it is required.
	NotificationTimes pulumi.StringArrayOutput `pulumi:"notificationTimes"`
	// Order of the condition in conditions list
	Order     pulumi.IntOutput                    `pulumi:"order"`
	Repeats   NotificationRuleRepeatArrayOutput   `pulumi:"repeats"`
	Schedules NotificationRuleScheduleArrayOutput `pulumi:"schedules"`
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            NotificationRuleStepArrayOutput            `pulumi:"steps"`
	TimeRestrictions NotificationRuleTimeRestrictionArrayOutput `pulumi:"timeRestrictions"`
	// Username of user to which this notification rule belongs to.
	Username pulumi.StringOutput `pulumi:"username"`
}

// NewNotificationRule registers a new resource with the given unique name, arguments, and options.
func NewNotificationRule(ctx *pulumi.Context,
	name string, args *NotificationRuleArgs, opts ...pulumi.ResourceOption) (*NotificationRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ActionType == nil {
		return nil, errors.New("invalid value for required argument 'ActionType'")
	}
	if args.Username == nil {
		return nil, errors.New("invalid value for required argument 'Username'")
	}
	var resource NotificationRule
	err := ctx.RegisterResource("opsgenie:index/notificationRule:NotificationRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNotificationRule gets an existing NotificationRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNotificationRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NotificationRuleState, opts ...pulumi.ResourceOption) (*NotificationRule, error) {
	var resource NotificationRule
	err := ctx.ReadResource("opsgenie:index/notificationRule:NotificationRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NotificationRule resources.
type notificationRuleState struct {
	// Type of the action that notification rule will have. Allowed values: "create-alert", "acknowledged-alert", "closed-alert", "assigned-alert", "add-note", "schedule-start", "schedule-end", "incoming-call-routing"
	ActionType *string                    `pulumi:"actionType"`
	Criterias  []NotificationRuleCriteria `pulumi:"criterias"`
	// Defined if this step is enabled. Default: true
	Enabled *bool `pulumi:"enabled"`
	// Name of the notification policy
	Name *string `pulumi:"name"`
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: "just-before", "15-minutes-ago", "1-hour-ago", "1-day-ago". If `actionType` is "schedule-start" or "schedule-end" then it is required.
	NotificationTimes []string `pulumi:"notificationTimes"`
	// Order of the condition in conditions list
	Order     *int                       `pulumi:"order"`
	Repeats   []NotificationRuleRepeat   `pulumi:"repeats"`
	Schedules []NotificationRuleSchedule `pulumi:"schedules"`
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            []NotificationRuleStep            `pulumi:"steps"`
	TimeRestrictions []NotificationRuleTimeRestriction `pulumi:"timeRestrictions"`
	// Username of user to which this notification rule belongs to.
	Username *string `pulumi:"username"`
}

type NotificationRuleState struct {
	// Type of the action that notification rule will have. Allowed values: "create-alert", "acknowledged-alert", "closed-alert", "assigned-alert", "add-note", "schedule-start", "schedule-end", "incoming-call-routing"
	ActionType pulumi.StringPtrInput
	Criterias  NotificationRuleCriteriaArrayInput
	// Defined if this step is enabled. Default: true
	Enabled pulumi.BoolPtrInput
	// Name of the notification policy
	Name pulumi.StringPtrInput
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: "just-before", "15-minutes-ago", "1-hour-ago", "1-day-ago". If `actionType` is "schedule-start" or "schedule-end" then it is required.
	NotificationTimes pulumi.StringArrayInput
	// Order of the condition in conditions list
	Order     pulumi.IntPtrInput
	Repeats   NotificationRuleRepeatArrayInput
	Schedules NotificationRuleScheduleArrayInput
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            NotificationRuleStepArrayInput
	TimeRestrictions NotificationRuleTimeRestrictionArrayInput
	// Username of user to which this notification rule belongs to.
	Username pulumi.StringPtrInput
}

func (NotificationRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*notificationRuleState)(nil)).Elem()
}

type notificationRuleArgs struct {
	// Type of the action that notification rule will have. Allowed values: "create-alert", "acknowledged-alert", "closed-alert", "assigned-alert", "add-note", "schedule-start", "schedule-end", "incoming-call-routing"
	ActionType string                     `pulumi:"actionType"`
	Criterias  []NotificationRuleCriteria `pulumi:"criterias"`
	// Defined if this step is enabled. Default: true
	Enabled *bool `pulumi:"enabled"`
	// Name of the notification policy
	Name *string `pulumi:"name"`
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: "just-before", "15-minutes-ago", "1-hour-ago", "1-day-ago". If `actionType` is "schedule-start" or "schedule-end" then it is required.
	NotificationTimes []string `pulumi:"notificationTimes"`
	// Order of the condition in conditions list
	Order     *int                       `pulumi:"order"`
	Repeats   []NotificationRuleRepeat   `pulumi:"repeats"`
	Schedules []NotificationRuleSchedule `pulumi:"schedules"`
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            []NotificationRuleStep            `pulumi:"steps"`
	TimeRestrictions []NotificationRuleTimeRestriction `pulumi:"timeRestrictions"`
	// Username of user to which this notification rule belongs to.
	Username string `pulumi:"username"`
}

// The set of arguments for constructing a NotificationRule resource.
type NotificationRuleArgs struct {
	// Type of the action that notification rule will have. Allowed values: "create-alert", "acknowledged-alert", "closed-alert", "assigned-alert", "add-note", "schedule-start", "schedule-end", "incoming-call-routing"
	ActionType pulumi.StringInput
	Criterias  NotificationRuleCriteriaArrayInput
	// Defined if this step is enabled. Default: true
	Enabled pulumi.BoolPtrInput
	// Name of the notification policy
	Name pulumi.StringPtrInput
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: "just-before", "15-minutes-ago", "1-hour-ago", "1-day-ago". If `actionType` is "schedule-start" or "schedule-end" then it is required.
	NotificationTimes pulumi.StringArrayInput
	// Order of the condition in conditions list
	Order     pulumi.IntPtrInput
	Repeats   NotificationRuleRepeatArrayInput
	Schedules NotificationRuleScheduleArrayInput
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            NotificationRuleStepArrayInput
	TimeRestrictions NotificationRuleTimeRestrictionArrayInput
	// Username of user to which this notification rule belongs to.
	Username pulumi.StringInput
}

func (NotificationRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*notificationRuleArgs)(nil)).Elem()
}

type NotificationRuleInput interface {
	pulumi.Input

	ToNotificationRuleOutput() NotificationRuleOutput
	ToNotificationRuleOutputWithContext(ctx context.Context) NotificationRuleOutput
}

func (NotificationRule) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationRule)(nil)).Elem()
}

func (i NotificationRule) ToNotificationRuleOutput() NotificationRuleOutput {
	return i.ToNotificationRuleOutputWithContext(context.Background())
}

func (i NotificationRule) ToNotificationRuleOutputWithContext(ctx context.Context) NotificationRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRuleOutput)
}

type NotificationRuleOutput struct {
	*pulumi.OutputState
}

func (NotificationRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationRuleOutput)(nil)).Elem()
}

func (o NotificationRuleOutput) ToNotificationRuleOutput() NotificationRuleOutput {
	return o
}

func (o NotificationRuleOutput) ToNotificationRuleOutputWithContext(ctx context.Context) NotificationRuleOutput {
	return o
}

func init() {
	pulumi.RegisterOutputType(NotificationRuleOutput{})
}
