// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package opsgenie

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Notification Rule within Opsgenie.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-opsgenie/sdk/go/opsgenie"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		testUser, err := opsgenie.NewUser(ctx, "testUser", &opsgenie.UserArgs{
// 			Username: pulumi.String("Example user"),
// 			FullName: pulumi.String("Name Lastname"),
// 			Role:     pulumi.String("User"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = opsgenie.NewNotificationRule(ctx, "testNotificationRule", &opsgenie.NotificationRuleArgs{
// 			Username:   testUser.Username,
// 			ActionType: pulumi.String("schedule-end"),
// 			NotificationTimes: pulumi.StringArray{
// 				pulumi.String("just-before"),
// 				pulumi.String("15-minutes-ago"),
// 			},
// 			Steps: opsgenie.NotificationRuleStepArray{
// 				&opsgenie.NotificationRuleStepArgs{
// 					Contacts: opsgenie.NotificationRuleStepContactArray{
// 						&opsgenie.NotificationRuleStepContactArgs{
// 							Method: pulumi.String("email"),
// 							To:     pulumi.String("example@user.com"),
// 						},
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Notification policies can be imported using the `user_id/notification_rule_id`, e.g.
//
// ```sh
//  $ pulumi import opsgenie:index/notificationRule:NotificationRule test user_id/notification_rule_id`
// ```
type NotificationRule struct {
	pulumi.CustomResourceState

	// Type of the action that notification rule will have. Allowed values: `create-alert`, `acknowledged-alert`, `closed-alert`, `assigned-alert`, `add-note`, `schedule-start`, `schedule-end`, `incoming-call-routing`
	ActionType pulumi.StringOutput                 `pulumi:"actionType"`
	Criterias  NotificationRuleCriteriaArrayOutput `pulumi:"criterias"`
	// Defined if this step is enabled. Default: `true`
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// Name of the notification policy
	Name pulumi.StringOutput `pulumi:"name"`
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: `just-before`, `15-minutes-ago`, `1-hour-ago`, `1-day-ago`. If `actionType` is `schedule-start` or `schedule-end` then it is required.
	NotificationTimes pulumi.StringArrayOutput `pulumi:"notificationTimes"`
	// Order of the condition in conditions list
	Order     pulumi.IntOutput                    `pulumi:"order"`
	Repeats   NotificationRuleRepeatArrayOutput   `pulumi:"repeats"`
	Schedules NotificationRuleScheduleArrayOutput `pulumi:"schedules"`
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            NotificationRuleStepArrayOutput            `pulumi:"steps"`
	TimeRestrictions NotificationRuleTimeRestrictionArrayOutput `pulumi:"timeRestrictions"`
	// Username of user to which this notification rule belongs to.
	Username pulumi.StringOutput `pulumi:"username"`
}

// NewNotificationRule registers a new resource with the given unique name, arguments, and options.
func NewNotificationRule(ctx *pulumi.Context,
	name string, args *NotificationRuleArgs, opts ...pulumi.ResourceOption) (*NotificationRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ActionType == nil {
		return nil, errors.New("invalid value for required argument 'ActionType'")
	}
	if args.Username == nil {
		return nil, errors.New("invalid value for required argument 'Username'")
	}
	var resource NotificationRule
	err := ctx.RegisterResource("opsgenie:index/notificationRule:NotificationRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNotificationRule gets an existing NotificationRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNotificationRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NotificationRuleState, opts ...pulumi.ResourceOption) (*NotificationRule, error) {
	var resource NotificationRule
	err := ctx.ReadResource("opsgenie:index/notificationRule:NotificationRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NotificationRule resources.
type notificationRuleState struct {
	// Type of the action that notification rule will have. Allowed values: `create-alert`, `acknowledged-alert`, `closed-alert`, `assigned-alert`, `add-note`, `schedule-start`, `schedule-end`, `incoming-call-routing`
	ActionType *string                    `pulumi:"actionType"`
	Criterias  []NotificationRuleCriteria `pulumi:"criterias"`
	// Defined if this step is enabled. Default: `true`
	Enabled *bool `pulumi:"enabled"`
	// Name of the notification policy
	Name *string `pulumi:"name"`
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: `just-before`, `15-minutes-ago`, `1-hour-ago`, `1-day-ago`. If `actionType` is `schedule-start` or `schedule-end` then it is required.
	NotificationTimes []string `pulumi:"notificationTimes"`
	// Order of the condition in conditions list
	Order     *int                       `pulumi:"order"`
	Repeats   []NotificationRuleRepeat   `pulumi:"repeats"`
	Schedules []NotificationRuleSchedule `pulumi:"schedules"`
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            []NotificationRuleStep            `pulumi:"steps"`
	TimeRestrictions []NotificationRuleTimeRestriction `pulumi:"timeRestrictions"`
	// Username of user to which this notification rule belongs to.
	Username *string `pulumi:"username"`
}

type NotificationRuleState struct {
	// Type of the action that notification rule will have. Allowed values: `create-alert`, `acknowledged-alert`, `closed-alert`, `assigned-alert`, `add-note`, `schedule-start`, `schedule-end`, `incoming-call-routing`
	ActionType pulumi.StringPtrInput
	Criterias  NotificationRuleCriteriaArrayInput
	// Defined if this step is enabled. Default: `true`
	Enabled pulumi.BoolPtrInput
	// Name of the notification policy
	Name pulumi.StringPtrInput
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: `just-before`, `15-minutes-ago`, `1-hour-ago`, `1-day-ago`. If `actionType` is `schedule-start` or `schedule-end` then it is required.
	NotificationTimes pulumi.StringArrayInput
	// Order of the condition in conditions list
	Order     pulumi.IntPtrInput
	Repeats   NotificationRuleRepeatArrayInput
	Schedules NotificationRuleScheduleArrayInput
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            NotificationRuleStepArrayInput
	TimeRestrictions NotificationRuleTimeRestrictionArrayInput
	// Username of user to which this notification rule belongs to.
	Username pulumi.StringPtrInput
}

func (NotificationRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*notificationRuleState)(nil)).Elem()
}

type notificationRuleArgs struct {
	// Type of the action that notification rule will have. Allowed values: `create-alert`, `acknowledged-alert`, `closed-alert`, `assigned-alert`, `add-note`, `schedule-start`, `schedule-end`, `incoming-call-routing`
	ActionType string                     `pulumi:"actionType"`
	Criterias  []NotificationRuleCriteria `pulumi:"criterias"`
	// Defined if this step is enabled. Default: `true`
	Enabled *bool `pulumi:"enabled"`
	// Name of the notification policy
	Name *string `pulumi:"name"`
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: `just-before`, `15-minutes-ago`, `1-hour-ago`, `1-day-ago`. If `actionType` is `schedule-start` or `schedule-end` then it is required.
	NotificationTimes []string `pulumi:"notificationTimes"`
	// Order of the condition in conditions list
	Order     *int                       `pulumi:"order"`
	Repeats   []NotificationRuleRepeat   `pulumi:"repeats"`
	Schedules []NotificationRuleSchedule `pulumi:"schedules"`
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            []NotificationRuleStep            `pulumi:"steps"`
	TimeRestrictions []NotificationRuleTimeRestriction `pulumi:"timeRestrictions"`
	// Username of user to which this notification rule belongs to.
	Username string `pulumi:"username"`
}

// The set of arguments for constructing a NotificationRule resource.
type NotificationRuleArgs struct {
	// Type of the action that notification rule will have. Allowed values: `create-alert`, `acknowledged-alert`, `closed-alert`, `assigned-alert`, `add-note`, `schedule-start`, `schedule-end`, `incoming-call-routing`
	ActionType pulumi.StringInput
	Criterias  NotificationRuleCriteriaArrayInput
	// Defined if this step is enabled. Default: `true`
	Enabled pulumi.BoolPtrInput
	// Name of the notification policy
	Name pulumi.StringPtrInput
	// List of Time Periods that notification for schedule start/end will be sent. Allowed values: `just-before`, `15-minutes-ago`, `1-hour-ago`, `1-day-ago`. If `actionType` is `schedule-start` or `schedule-end` then it is required.
	NotificationTimes pulumi.StringArrayInput
	// Order of the condition in conditions list
	Order     pulumi.IntPtrInput
	Repeats   NotificationRuleRepeatArrayInput
	Schedules NotificationRuleScheduleArrayInput
	// Notification rule steps to take (eg. SMS or email message). This is a block, structure is documented below.
	Steps            NotificationRuleStepArrayInput
	TimeRestrictions NotificationRuleTimeRestrictionArrayInput
	// Username of user to which this notification rule belongs to.
	Username pulumi.StringInput
}

func (NotificationRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*notificationRuleArgs)(nil)).Elem()
}

type NotificationRuleInput interface {
	pulumi.Input

	ToNotificationRuleOutput() NotificationRuleOutput
	ToNotificationRuleOutputWithContext(ctx context.Context) NotificationRuleOutput
}

func (*NotificationRule) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationRule)(nil))
}

func (i *NotificationRule) ToNotificationRuleOutput() NotificationRuleOutput {
	return i.ToNotificationRuleOutputWithContext(context.Background())
}

func (i *NotificationRule) ToNotificationRuleOutputWithContext(ctx context.Context) NotificationRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRuleOutput)
}

func (i *NotificationRule) ToNotificationRulePtrOutput() NotificationRulePtrOutput {
	return i.ToNotificationRulePtrOutputWithContext(context.Background())
}

func (i *NotificationRule) ToNotificationRulePtrOutputWithContext(ctx context.Context) NotificationRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRulePtrOutput)
}

type NotificationRulePtrInput interface {
	pulumi.Input

	ToNotificationRulePtrOutput() NotificationRulePtrOutput
	ToNotificationRulePtrOutputWithContext(ctx context.Context) NotificationRulePtrOutput
}

type notificationRulePtrType NotificationRuleArgs

func (*notificationRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationRule)(nil))
}

func (i *notificationRulePtrType) ToNotificationRulePtrOutput() NotificationRulePtrOutput {
	return i.ToNotificationRulePtrOutputWithContext(context.Background())
}

func (i *notificationRulePtrType) ToNotificationRulePtrOutputWithContext(ctx context.Context) NotificationRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRulePtrOutput)
}

// NotificationRuleArrayInput is an input type that accepts NotificationRuleArray and NotificationRuleArrayOutput values.
// You can construct a concrete instance of `NotificationRuleArrayInput` via:
//
//          NotificationRuleArray{ NotificationRuleArgs{...} }
type NotificationRuleArrayInput interface {
	pulumi.Input

	ToNotificationRuleArrayOutput() NotificationRuleArrayOutput
	ToNotificationRuleArrayOutputWithContext(context.Context) NotificationRuleArrayOutput
}

type NotificationRuleArray []NotificationRuleInput

func (NotificationRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*NotificationRule)(nil))
}

func (i NotificationRuleArray) ToNotificationRuleArrayOutput() NotificationRuleArrayOutput {
	return i.ToNotificationRuleArrayOutputWithContext(context.Background())
}

func (i NotificationRuleArray) ToNotificationRuleArrayOutputWithContext(ctx context.Context) NotificationRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRuleArrayOutput)
}

// NotificationRuleMapInput is an input type that accepts NotificationRuleMap and NotificationRuleMapOutput values.
// You can construct a concrete instance of `NotificationRuleMapInput` via:
//
//          NotificationRuleMap{ "key": NotificationRuleArgs{...} }
type NotificationRuleMapInput interface {
	pulumi.Input

	ToNotificationRuleMapOutput() NotificationRuleMapOutput
	ToNotificationRuleMapOutputWithContext(context.Context) NotificationRuleMapOutput
}

type NotificationRuleMap map[string]NotificationRuleInput

func (NotificationRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*NotificationRule)(nil))
}

func (i NotificationRuleMap) ToNotificationRuleMapOutput() NotificationRuleMapOutput {
	return i.ToNotificationRuleMapOutputWithContext(context.Background())
}

func (i NotificationRuleMap) ToNotificationRuleMapOutputWithContext(ctx context.Context) NotificationRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRuleMapOutput)
}

type NotificationRuleOutput struct {
	*pulumi.OutputState
}

func (NotificationRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationRule)(nil))
}

func (o NotificationRuleOutput) ToNotificationRuleOutput() NotificationRuleOutput {
	return o
}

func (o NotificationRuleOutput) ToNotificationRuleOutputWithContext(ctx context.Context) NotificationRuleOutput {
	return o
}

func (o NotificationRuleOutput) ToNotificationRulePtrOutput() NotificationRulePtrOutput {
	return o.ToNotificationRulePtrOutputWithContext(context.Background())
}

func (o NotificationRuleOutput) ToNotificationRulePtrOutputWithContext(ctx context.Context) NotificationRulePtrOutput {
	return o.ApplyT(func(v NotificationRule) *NotificationRule {
		return &v
	}).(NotificationRulePtrOutput)
}

type NotificationRulePtrOutput struct {
	*pulumi.OutputState
}

func (NotificationRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationRule)(nil))
}

func (o NotificationRulePtrOutput) ToNotificationRulePtrOutput() NotificationRulePtrOutput {
	return o
}

func (o NotificationRulePtrOutput) ToNotificationRulePtrOutputWithContext(ctx context.Context) NotificationRulePtrOutput {
	return o
}

type NotificationRuleArrayOutput struct{ *pulumi.OutputState }

func (NotificationRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NotificationRule)(nil))
}

func (o NotificationRuleArrayOutput) ToNotificationRuleArrayOutput() NotificationRuleArrayOutput {
	return o
}

func (o NotificationRuleArrayOutput) ToNotificationRuleArrayOutputWithContext(ctx context.Context) NotificationRuleArrayOutput {
	return o
}

func (o NotificationRuleArrayOutput) Index(i pulumi.IntInput) NotificationRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NotificationRule {
		return vs[0].([]NotificationRule)[vs[1].(int)]
	}).(NotificationRuleOutput)
}

type NotificationRuleMapOutput struct{ *pulumi.OutputState }

func (NotificationRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]NotificationRule)(nil))
}

func (o NotificationRuleMapOutput) ToNotificationRuleMapOutput() NotificationRuleMapOutput {
	return o
}

func (o NotificationRuleMapOutput) ToNotificationRuleMapOutputWithContext(ctx context.Context) NotificationRuleMapOutput {
	return o
}

func (o NotificationRuleMapOutput) MapIndex(k pulumi.StringInput) NotificationRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) NotificationRule {
		return vs[0].(map[string]NotificationRule)[vs[1].(string)]
	}).(NotificationRuleOutput)
}

func init() {
	pulumi.RegisterOutputType(NotificationRuleOutput{})
	pulumi.RegisterOutputType(NotificationRulePtrOutput{})
	pulumi.RegisterOutputType(NotificationRuleArrayOutput{})
	pulumi.RegisterOutputType(NotificationRuleMapOutput{})
}
