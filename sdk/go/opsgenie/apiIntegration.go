// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package opsgenie

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an API Integration within Opsgenie.
//
// ## Import
//
// API Integrations can be imported using the `id`, e.g.
//
// ```sh
//  $ pulumi import opsgenie:index/apiIntegration:ApiIntegration defaultintegration 812be1a1-32c8-4666-a7fb-03ecc385106c`
// ```
type ApiIntegration struct {
	pulumi.CustomResourceState

	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Defaults to true.
	AllowWriteAccess pulumi.BoolPtrOutput `pulumi:"allowWriteAccess"`
	// (Computed) API key of the created integration
	ApiKey pulumi.StringOutput `pulumi:"apiKey"`
	// This parameter is for specifying whether the integration will be enabled or not. Defaults to true
	Enabled pulumi.BoolPtrOutput   `pulumi:"enabled"`
	Headers pulumi.StringMapOutput `pulumi:"headers"`
	// If enabled, the integration will ignore recipients sent in request payloads. Defaults to false.
	IgnoreRespondersFromPayload pulumi.BoolPtrOutput `pulumi:"ignoreRespondersFromPayload"`
	// Name of the integration. Name must be unique for each integration.
	Name pulumi.StringOutput `pulumi:"name"`
	// Owner team id of the integration.
	OwnerTeamId pulumi.StringPtrOutput `pulumi:"ownerTeamId"`
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders ApiIntegrationResponderArrayOutput `pulumi:"responders"`
	// If enabled, notifications that come from alerts will be suppressed. Defaults to false.
	SuppressNotifications pulumi.BoolPtrOutput `pulumi:"suppressNotifications"`
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type pulumi.StringPtrOutput `pulumi:"type"`
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl pulumi.StringPtrOutput `pulumi:"webhookUrl"`
}

// NewApiIntegration registers a new resource with the given unique name, arguments, and options.
func NewApiIntegration(ctx *pulumi.Context,
	name string, args *ApiIntegrationArgs, opts ...pulumi.ResourceOption) (*ApiIntegration, error) {
	if args == nil {
		args = &ApiIntegrationArgs{}
	}

	var resource ApiIntegration
	err := ctx.RegisterResource("opsgenie:index/apiIntegration:ApiIntegration", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApiIntegration gets an existing ApiIntegration resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApiIntegration(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApiIntegrationState, opts ...pulumi.ResourceOption) (*ApiIntegration, error) {
	var resource ApiIntegration
	err := ctx.ReadResource("opsgenie:index/apiIntegration:ApiIntegration", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApiIntegration resources.
type apiIntegrationState struct {
	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Defaults to true.
	AllowWriteAccess *bool `pulumi:"allowWriteAccess"`
	// (Computed) API key of the created integration
	ApiKey *string `pulumi:"apiKey"`
	// This parameter is for specifying whether the integration will be enabled or not. Defaults to true
	Enabled *bool             `pulumi:"enabled"`
	Headers map[string]string `pulumi:"headers"`
	// If enabled, the integration will ignore recipients sent in request payloads. Defaults to false.
	IgnoreRespondersFromPayload *bool `pulumi:"ignoreRespondersFromPayload"`
	// Name of the integration. Name must be unique for each integration.
	Name *string `pulumi:"name"`
	// Owner team id of the integration.
	OwnerTeamId *string `pulumi:"ownerTeamId"`
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders []ApiIntegrationResponder `pulumi:"responders"`
	// If enabled, notifications that come from alerts will be suppressed. Defaults to false.
	SuppressNotifications *bool `pulumi:"suppressNotifications"`
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type *string `pulumi:"type"`
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl *string `pulumi:"webhookUrl"`
}

type ApiIntegrationState struct {
	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Defaults to true.
	AllowWriteAccess pulumi.BoolPtrInput
	// (Computed) API key of the created integration
	ApiKey pulumi.StringPtrInput
	// This parameter is for specifying whether the integration will be enabled or not. Defaults to true
	Enabled pulumi.BoolPtrInput
	Headers pulumi.StringMapInput
	// If enabled, the integration will ignore recipients sent in request payloads. Defaults to false.
	IgnoreRespondersFromPayload pulumi.BoolPtrInput
	// Name of the integration. Name must be unique for each integration.
	Name pulumi.StringPtrInput
	// Owner team id of the integration.
	OwnerTeamId pulumi.StringPtrInput
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders ApiIntegrationResponderArrayInput
	// If enabled, notifications that come from alerts will be suppressed. Defaults to false.
	SuppressNotifications pulumi.BoolPtrInput
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type pulumi.StringPtrInput
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl pulumi.StringPtrInput
}

func (ApiIntegrationState) ElementType() reflect.Type {
	return reflect.TypeOf((*apiIntegrationState)(nil)).Elem()
}

type apiIntegrationArgs struct {
	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Defaults to true.
	AllowWriteAccess *bool `pulumi:"allowWriteAccess"`
	// This parameter is for specifying whether the integration will be enabled or not. Defaults to true
	Enabled *bool             `pulumi:"enabled"`
	Headers map[string]string `pulumi:"headers"`
	// If enabled, the integration will ignore recipients sent in request payloads. Defaults to false.
	IgnoreRespondersFromPayload *bool `pulumi:"ignoreRespondersFromPayload"`
	// Name of the integration. Name must be unique for each integration.
	Name *string `pulumi:"name"`
	// Owner team id of the integration.
	OwnerTeamId *string `pulumi:"ownerTeamId"`
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders []ApiIntegrationResponder `pulumi:"responders"`
	// If enabled, notifications that come from alerts will be suppressed. Defaults to false.
	SuppressNotifications *bool `pulumi:"suppressNotifications"`
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type *string `pulumi:"type"`
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl *string `pulumi:"webhookUrl"`
}

// The set of arguments for constructing a ApiIntegration resource.
type ApiIntegrationArgs struct {
	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Defaults to true.
	AllowWriteAccess pulumi.BoolPtrInput
	// This parameter is for specifying whether the integration will be enabled or not. Defaults to true
	Enabled pulumi.BoolPtrInput
	Headers pulumi.StringMapInput
	// If enabled, the integration will ignore recipients sent in request payloads. Defaults to false.
	IgnoreRespondersFromPayload pulumi.BoolPtrInput
	// Name of the integration. Name must be unique for each integration.
	Name pulumi.StringPtrInput
	// Owner team id of the integration.
	OwnerTeamId pulumi.StringPtrInput
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders ApiIntegrationResponderArrayInput
	// If enabled, notifications that come from alerts will be suppressed. Defaults to false.
	SuppressNotifications pulumi.BoolPtrInput
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type pulumi.StringPtrInput
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl pulumi.StringPtrInput
}

func (ApiIntegrationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*apiIntegrationArgs)(nil)).Elem()
}

type ApiIntegrationInput interface {
	pulumi.Input

	ToApiIntegrationOutput() ApiIntegrationOutput
	ToApiIntegrationOutputWithContext(ctx context.Context) ApiIntegrationOutput
}

func (*ApiIntegration) ElementType() reflect.Type {
	return reflect.TypeOf((*ApiIntegration)(nil))
}

func (i *ApiIntegration) ToApiIntegrationOutput() ApiIntegrationOutput {
	return i.ToApiIntegrationOutputWithContext(context.Background())
}

func (i *ApiIntegration) ToApiIntegrationOutputWithContext(ctx context.Context) ApiIntegrationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiIntegrationOutput)
}

func (i *ApiIntegration) ToApiIntegrationPtrOutput() ApiIntegrationPtrOutput {
	return i.ToApiIntegrationPtrOutputWithContext(context.Background())
}

func (i *ApiIntegration) ToApiIntegrationPtrOutputWithContext(ctx context.Context) ApiIntegrationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiIntegrationPtrOutput)
}

type ApiIntegrationPtrInput interface {
	pulumi.Input

	ToApiIntegrationPtrOutput() ApiIntegrationPtrOutput
	ToApiIntegrationPtrOutputWithContext(ctx context.Context) ApiIntegrationPtrOutput
}

type apiIntegrationPtrType ApiIntegrationArgs

func (*apiIntegrationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApiIntegration)(nil))
}

func (i *apiIntegrationPtrType) ToApiIntegrationPtrOutput() ApiIntegrationPtrOutput {
	return i.ToApiIntegrationPtrOutputWithContext(context.Background())
}

func (i *apiIntegrationPtrType) ToApiIntegrationPtrOutputWithContext(ctx context.Context) ApiIntegrationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiIntegrationPtrOutput)
}

// ApiIntegrationArrayInput is an input type that accepts ApiIntegrationArray and ApiIntegrationArrayOutput values.
// You can construct a concrete instance of `ApiIntegrationArrayInput` via:
//
//          ApiIntegrationArray{ ApiIntegrationArgs{...} }
type ApiIntegrationArrayInput interface {
	pulumi.Input

	ToApiIntegrationArrayOutput() ApiIntegrationArrayOutput
	ToApiIntegrationArrayOutputWithContext(context.Context) ApiIntegrationArrayOutput
}

type ApiIntegrationArray []ApiIntegrationInput

func (ApiIntegrationArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*ApiIntegration)(nil))
}

func (i ApiIntegrationArray) ToApiIntegrationArrayOutput() ApiIntegrationArrayOutput {
	return i.ToApiIntegrationArrayOutputWithContext(context.Background())
}

func (i ApiIntegrationArray) ToApiIntegrationArrayOutputWithContext(ctx context.Context) ApiIntegrationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiIntegrationArrayOutput)
}

// ApiIntegrationMapInput is an input type that accepts ApiIntegrationMap and ApiIntegrationMapOutput values.
// You can construct a concrete instance of `ApiIntegrationMapInput` via:
//
//          ApiIntegrationMap{ "key": ApiIntegrationArgs{...} }
type ApiIntegrationMapInput interface {
	pulumi.Input

	ToApiIntegrationMapOutput() ApiIntegrationMapOutput
	ToApiIntegrationMapOutputWithContext(context.Context) ApiIntegrationMapOutput
}

type ApiIntegrationMap map[string]ApiIntegrationInput

func (ApiIntegrationMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*ApiIntegration)(nil))
}

func (i ApiIntegrationMap) ToApiIntegrationMapOutput() ApiIntegrationMapOutput {
	return i.ToApiIntegrationMapOutputWithContext(context.Background())
}

func (i ApiIntegrationMap) ToApiIntegrationMapOutputWithContext(ctx context.Context) ApiIntegrationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiIntegrationMapOutput)
}

type ApiIntegrationOutput struct {
	*pulumi.OutputState
}

func (ApiIntegrationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApiIntegration)(nil))
}

func (o ApiIntegrationOutput) ToApiIntegrationOutput() ApiIntegrationOutput {
	return o
}

func (o ApiIntegrationOutput) ToApiIntegrationOutputWithContext(ctx context.Context) ApiIntegrationOutput {
	return o
}

func (o ApiIntegrationOutput) ToApiIntegrationPtrOutput() ApiIntegrationPtrOutput {
	return o.ToApiIntegrationPtrOutputWithContext(context.Background())
}

func (o ApiIntegrationOutput) ToApiIntegrationPtrOutputWithContext(ctx context.Context) ApiIntegrationPtrOutput {
	return o.ApplyT(func(v ApiIntegration) *ApiIntegration {
		return &v
	}).(ApiIntegrationPtrOutput)
}

type ApiIntegrationPtrOutput struct {
	*pulumi.OutputState
}

func (ApiIntegrationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApiIntegration)(nil))
}

func (o ApiIntegrationPtrOutput) ToApiIntegrationPtrOutput() ApiIntegrationPtrOutput {
	return o
}

func (o ApiIntegrationPtrOutput) ToApiIntegrationPtrOutputWithContext(ctx context.Context) ApiIntegrationPtrOutput {
	return o
}

type ApiIntegrationArrayOutput struct{ *pulumi.OutputState }

func (ApiIntegrationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApiIntegration)(nil))
}

func (o ApiIntegrationArrayOutput) ToApiIntegrationArrayOutput() ApiIntegrationArrayOutput {
	return o
}

func (o ApiIntegrationArrayOutput) ToApiIntegrationArrayOutputWithContext(ctx context.Context) ApiIntegrationArrayOutput {
	return o
}

func (o ApiIntegrationArrayOutput) Index(i pulumi.IntInput) ApiIntegrationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApiIntegration {
		return vs[0].([]ApiIntegration)[vs[1].(int)]
	}).(ApiIntegrationOutput)
}

type ApiIntegrationMapOutput struct{ *pulumi.OutputState }

func (ApiIntegrationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ApiIntegration)(nil))
}

func (o ApiIntegrationMapOutput) ToApiIntegrationMapOutput() ApiIntegrationMapOutput {
	return o
}

func (o ApiIntegrationMapOutput) ToApiIntegrationMapOutputWithContext(ctx context.Context) ApiIntegrationMapOutput {
	return o
}

func (o ApiIntegrationMapOutput) MapIndex(k pulumi.StringInput) ApiIntegrationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ApiIntegration {
		return vs[0].(map[string]ApiIntegration)[vs[1].(string)]
	}).(ApiIntegrationOutput)
}

func init() {
	pulumi.RegisterOutputType(ApiIntegrationOutput{})
	pulumi.RegisterOutputType(ApiIntegrationPtrOutput{})
	pulumi.RegisterOutputType(ApiIntegrationArrayOutput{})
	pulumi.RegisterOutputType(ApiIntegrationMapOutput{})
}
