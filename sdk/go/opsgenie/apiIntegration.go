// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package opsgenie

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-opsgenie/sdk/go/opsgenie/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Manages an API Integration within Opsgenie.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-opsgenie/sdk/go/opsgenie"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := opsgenie.NewApiIntegration(ctx, "example-api-integrationApiIntegration", &opsgenie.ApiIntegrationArgs{
//				Type: pulumi.String("API"),
//				Responders: opsgenie.ApiIntegrationResponderArray{
//					&opsgenie.ApiIntegrationResponderArgs{
//						Type: pulumi.String("user"),
//						Id:   pulumi.Any(opsgenie_user.User.Id),
//					},
//					&opsgenie.ApiIntegrationResponderArgs{
//						Type: pulumi.String("user"),
//						Id:   pulumi.Any(opsgenie_user.Fahri.Id),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = opsgenie.NewApiIntegration(ctx, "example-api-integrationIndex/apiIntegrationApiIntegration", &opsgenie.ApiIntegrationArgs{
//				Type: pulumi.String("Prometheus"),
//				Responders: opsgenie.ApiIntegrationResponderArray{
//					&opsgenie.ApiIntegrationResponderArgs{
//						Type: pulumi.String("user"),
//						Id:   pulumi.Any(opsgenie_user.User.Id),
//					},
//				},
//				Enabled:                     pulumi.Bool(false),
//				AllowWriteAccess:            pulumi.Bool(false),
//				IgnoreRespondersFromPayload: pulumi.Bool(true),
//				SuppressNotifications:       pulumi.Bool(true),
//				OwnerTeamId:                 pulumi.Any(opsgenie_team.Team.Id),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = opsgenie.NewApiIntegration(ctx, "test3", &opsgenie.ApiIntegrationArgs{
//				Type: pulumi.String("Webhook"),
//				Responders: opsgenie.ApiIntegrationResponderArray{
//					&opsgenie.ApiIntegrationResponderArgs{
//						Type: pulumi.String("user"),
//						Id:   pulumi.Any(opsgenie_user.User.Id),
//					},
//				},
//				Enabled:               pulumi.Bool(false),
//				AllowWriteAccess:      pulumi.Bool(false),
//				SuppressNotifications: pulumi.Bool(true),
//				WebhookUrl:            pulumi.String("https://api.example.com/v1"),
//				Headers: pulumi.StringMap{
//					"header1": pulumi.Any(value1),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// API Integrations can be imported using the `integration_id`, e.g.
//
// ```sh
//
//	$ pulumi import opsgenie:index/apiIntegration:ApiIntegration this integration_id`
//
// ```
type ApiIntegration struct {
	pulumi.CustomResourceState

	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Default: `true`.
	AllowWriteAccess pulumi.BoolPtrOutput `pulumi:"allowWriteAccess"`
	// (Computed) API key of the created integration
	ApiKey pulumi.StringOutput `pulumi:"apiKey"`
	// This parameter is for specifying whether the integration will be enabled or not. Default: `true`
	Enabled pulumi.BoolPtrOutput   `pulumi:"enabled"`
	Headers pulumi.StringMapOutput `pulumi:"headers"`
	// If enabled, the integration will ignore recipients sent in request payloads. Default: `false`.
	IgnoreRespondersFromPayload pulumi.BoolPtrOutput `pulumi:"ignoreRespondersFromPayload"`
	// Name of the integration. Name must be unique for each integration.
	Name pulumi.StringOutput `pulumi:"name"`
	// Owner team id of the integration. If changed, this will recreate a new API integration, which will probably have a different API key.
	OwnerTeamId pulumi.StringPtrOutput `pulumi:"ownerTeamId"`
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders ApiIntegrationResponderArrayOutput `pulumi:"responders"`
	// If enabled, notifications that come from alerts will be suppressed. Default: `false`.
	SuppressNotifications pulumi.BoolPtrOutput `pulumi:"suppressNotifications"`
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type pulumi.StringPtrOutput `pulumi:"type"`
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl pulumi.StringPtrOutput `pulumi:"webhookUrl"`
}

// NewApiIntegration registers a new resource with the given unique name, arguments, and options.
func NewApiIntegration(ctx *pulumi.Context,
	name string, args *ApiIntegrationArgs, opts ...pulumi.ResourceOption) (*ApiIntegration, error) {
	if args == nil {
		args = &ApiIntegrationArgs{}
	}

	secrets := pulumi.AdditionalSecretOutputs([]string{
		"apiKey",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ApiIntegration
	err := ctx.RegisterResource("opsgenie:index/apiIntegration:ApiIntegration", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApiIntegration gets an existing ApiIntegration resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApiIntegration(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApiIntegrationState, opts ...pulumi.ResourceOption) (*ApiIntegration, error) {
	var resource ApiIntegration
	err := ctx.ReadResource("opsgenie:index/apiIntegration:ApiIntegration", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApiIntegration resources.
type apiIntegrationState struct {
	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Default: `true`.
	AllowWriteAccess *bool `pulumi:"allowWriteAccess"`
	// (Computed) API key of the created integration
	ApiKey *string `pulumi:"apiKey"`
	// This parameter is for specifying whether the integration will be enabled or not. Default: `true`
	Enabled *bool             `pulumi:"enabled"`
	Headers map[string]string `pulumi:"headers"`
	// If enabled, the integration will ignore recipients sent in request payloads. Default: `false`.
	IgnoreRespondersFromPayload *bool `pulumi:"ignoreRespondersFromPayload"`
	// Name of the integration. Name must be unique for each integration.
	Name *string `pulumi:"name"`
	// Owner team id of the integration. If changed, this will recreate a new API integration, which will probably have a different API key.
	OwnerTeamId *string `pulumi:"ownerTeamId"`
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders []ApiIntegrationResponder `pulumi:"responders"`
	// If enabled, notifications that come from alerts will be suppressed. Default: `false`.
	SuppressNotifications *bool `pulumi:"suppressNotifications"`
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type *string `pulumi:"type"`
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl *string `pulumi:"webhookUrl"`
}

type ApiIntegrationState struct {
	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Default: `true`.
	AllowWriteAccess pulumi.BoolPtrInput
	// (Computed) API key of the created integration
	ApiKey pulumi.StringPtrInput
	// This parameter is for specifying whether the integration will be enabled or not. Default: `true`
	Enabled pulumi.BoolPtrInput
	Headers pulumi.StringMapInput
	// If enabled, the integration will ignore recipients sent in request payloads. Default: `false`.
	IgnoreRespondersFromPayload pulumi.BoolPtrInput
	// Name of the integration. Name must be unique for each integration.
	Name pulumi.StringPtrInput
	// Owner team id of the integration. If changed, this will recreate a new API integration, which will probably have a different API key.
	OwnerTeamId pulumi.StringPtrInput
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders ApiIntegrationResponderArrayInput
	// If enabled, notifications that come from alerts will be suppressed. Default: `false`.
	SuppressNotifications pulumi.BoolPtrInput
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type pulumi.StringPtrInput
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl pulumi.StringPtrInput
}

func (ApiIntegrationState) ElementType() reflect.Type {
	return reflect.TypeOf((*apiIntegrationState)(nil)).Elem()
}

type apiIntegrationArgs struct {
	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Default: `true`.
	AllowWriteAccess *bool `pulumi:"allowWriteAccess"`
	// This parameter is for specifying whether the integration will be enabled or not. Default: `true`
	Enabled *bool             `pulumi:"enabled"`
	Headers map[string]string `pulumi:"headers"`
	// If enabled, the integration will ignore recipients sent in request payloads. Default: `false`.
	IgnoreRespondersFromPayload *bool `pulumi:"ignoreRespondersFromPayload"`
	// Name of the integration. Name must be unique for each integration.
	Name *string `pulumi:"name"`
	// Owner team id of the integration. If changed, this will recreate a new API integration, which will probably have a different API key.
	OwnerTeamId *string `pulumi:"ownerTeamId"`
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders []ApiIntegrationResponder `pulumi:"responders"`
	// If enabled, notifications that come from alerts will be suppressed. Default: `false`.
	SuppressNotifications *bool `pulumi:"suppressNotifications"`
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type *string `pulumi:"type"`
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl *string `pulumi:"webhookUrl"`
}

// The set of arguments for constructing a ApiIntegration resource.
type ApiIntegrationArgs struct {
	// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Default: `true`.
	AllowWriteAccess pulumi.BoolPtrInput
	// This parameter is for specifying whether the integration will be enabled or not. Default: `true`
	Enabled pulumi.BoolPtrInput
	Headers pulumi.StringMapInput
	// If enabled, the integration will ignore recipients sent in request payloads. Default: `false`.
	IgnoreRespondersFromPayload pulumi.BoolPtrInput
	// Name of the integration. Name must be unique for each integration.
	Name pulumi.StringPtrInput
	// Owner team id of the integration. If changed, this will recreate a new API integration, which will probably have a different API key.
	OwnerTeamId pulumi.StringPtrInput
	// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
	Responders ApiIntegrationResponderArrayInput
	// If enabled, notifications that come from alerts will be suppressed. Default: `false`.
	SuppressNotifications pulumi.BoolPtrInput
	// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
	Type pulumi.StringPtrInput
	// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
	WebhookUrl pulumi.StringPtrInput
}

func (ApiIntegrationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*apiIntegrationArgs)(nil)).Elem()
}

type ApiIntegrationInput interface {
	pulumi.Input

	ToApiIntegrationOutput() ApiIntegrationOutput
	ToApiIntegrationOutputWithContext(ctx context.Context) ApiIntegrationOutput
}

func (*ApiIntegration) ElementType() reflect.Type {
	return reflect.TypeOf((**ApiIntegration)(nil)).Elem()
}

func (i *ApiIntegration) ToApiIntegrationOutput() ApiIntegrationOutput {
	return i.ToApiIntegrationOutputWithContext(context.Background())
}

func (i *ApiIntegration) ToApiIntegrationOutputWithContext(ctx context.Context) ApiIntegrationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiIntegrationOutput)
}

func (i *ApiIntegration) ToOutput(ctx context.Context) pulumix.Output[*ApiIntegration] {
	return pulumix.Output[*ApiIntegration]{
		OutputState: i.ToApiIntegrationOutputWithContext(ctx).OutputState,
	}
}

// ApiIntegrationArrayInput is an input type that accepts ApiIntegrationArray and ApiIntegrationArrayOutput values.
// You can construct a concrete instance of `ApiIntegrationArrayInput` via:
//
//	ApiIntegrationArray{ ApiIntegrationArgs{...} }
type ApiIntegrationArrayInput interface {
	pulumi.Input

	ToApiIntegrationArrayOutput() ApiIntegrationArrayOutput
	ToApiIntegrationArrayOutputWithContext(context.Context) ApiIntegrationArrayOutput
}

type ApiIntegrationArray []ApiIntegrationInput

func (ApiIntegrationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApiIntegration)(nil)).Elem()
}

func (i ApiIntegrationArray) ToApiIntegrationArrayOutput() ApiIntegrationArrayOutput {
	return i.ToApiIntegrationArrayOutputWithContext(context.Background())
}

func (i ApiIntegrationArray) ToApiIntegrationArrayOutputWithContext(ctx context.Context) ApiIntegrationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiIntegrationArrayOutput)
}

func (i ApiIntegrationArray) ToOutput(ctx context.Context) pulumix.Output[[]*ApiIntegration] {
	return pulumix.Output[[]*ApiIntegration]{
		OutputState: i.ToApiIntegrationArrayOutputWithContext(ctx).OutputState,
	}
}

// ApiIntegrationMapInput is an input type that accepts ApiIntegrationMap and ApiIntegrationMapOutput values.
// You can construct a concrete instance of `ApiIntegrationMapInput` via:
//
//	ApiIntegrationMap{ "key": ApiIntegrationArgs{...} }
type ApiIntegrationMapInput interface {
	pulumi.Input

	ToApiIntegrationMapOutput() ApiIntegrationMapOutput
	ToApiIntegrationMapOutputWithContext(context.Context) ApiIntegrationMapOutput
}

type ApiIntegrationMap map[string]ApiIntegrationInput

func (ApiIntegrationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApiIntegration)(nil)).Elem()
}

func (i ApiIntegrationMap) ToApiIntegrationMapOutput() ApiIntegrationMapOutput {
	return i.ToApiIntegrationMapOutputWithContext(context.Background())
}

func (i ApiIntegrationMap) ToApiIntegrationMapOutputWithContext(ctx context.Context) ApiIntegrationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiIntegrationMapOutput)
}

func (i ApiIntegrationMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*ApiIntegration] {
	return pulumix.Output[map[string]*ApiIntegration]{
		OutputState: i.ToApiIntegrationMapOutputWithContext(ctx).OutputState,
	}
}

type ApiIntegrationOutput struct{ *pulumi.OutputState }

func (ApiIntegrationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApiIntegration)(nil)).Elem()
}

func (o ApiIntegrationOutput) ToApiIntegrationOutput() ApiIntegrationOutput {
	return o
}

func (o ApiIntegrationOutput) ToApiIntegrationOutputWithContext(ctx context.Context) ApiIntegrationOutput {
	return o
}

func (o ApiIntegrationOutput) ToOutput(ctx context.Context) pulumix.Output[*ApiIntegration] {
	return pulumix.Output[*ApiIntegration]{
		OutputState: o.OutputState,
	}
}

// This parameter is for configuring the write access of integration. If write access is restricted, the integration will not be authorized to write within any domain. Default: `true`.
func (o ApiIntegrationOutput) AllowWriteAccess() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.BoolPtrOutput { return v.AllowWriteAccess }).(pulumi.BoolPtrOutput)
}

// (Computed) API key of the created integration
func (o ApiIntegrationOutput) ApiKey() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.StringOutput { return v.ApiKey }).(pulumi.StringOutput)
}

// This parameter is for specifying whether the integration will be enabled or not. Default: `true`
func (o ApiIntegrationOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

func (o ApiIntegrationOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.StringMapOutput { return v.Headers }).(pulumi.StringMapOutput)
}

// If enabled, the integration will ignore recipients sent in request payloads. Default: `false`.
func (o ApiIntegrationOutput) IgnoreRespondersFromPayload() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.BoolPtrOutput { return v.IgnoreRespondersFromPayload }).(pulumi.BoolPtrOutput)
}

// Name of the integration. Name must be unique for each integration.
func (o ApiIntegrationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Owner team id of the integration. If changed, this will recreate a new API integration, which will probably have a different API key.
func (o ApiIntegrationOutput) OwnerTeamId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.StringPtrOutput { return v.OwnerTeamId }).(pulumi.StringPtrOutput)
}

// User, schedule, teams or escalation names to calculate which users will receive the notifications of the alert.
func (o ApiIntegrationOutput) Responders() ApiIntegrationResponderArrayOutput {
	return o.ApplyT(func(v *ApiIntegration) ApiIntegrationResponderArrayOutput { return v.Responders }).(ApiIntegrationResponderArrayOutput)
}

// If enabled, notifications that come from alerts will be suppressed. Default: `false`.
func (o ApiIntegrationOutput) SuppressNotifications() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.BoolPtrOutput { return v.SuppressNotifications }).(pulumi.BoolPtrOutput)
}

// Type of the integration (API, Marid, Prometheus, etc). The full list of options can be found [here](https://docs.opsgenie.com/docs/integration-types-to-use-with-api).
func (o ApiIntegrationOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.StringPtrOutput { return v.Type }).(pulumi.StringPtrOutput)
}

// It is required if type is `Webhook`. This is the url Opsgenie will be sending request to.
func (o ApiIntegrationOutput) WebhookUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApiIntegration) pulumi.StringPtrOutput { return v.WebhookUrl }).(pulumi.StringPtrOutput)
}

type ApiIntegrationArrayOutput struct{ *pulumi.OutputState }

func (ApiIntegrationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApiIntegration)(nil)).Elem()
}

func (o ApiIntegrationArrayOutput) ToApiIntegrationArrayOutput() ApiIntegrationArrayOutput {
	return o
}

func (o ApiIntegrationArrayOutput) ToApiIntegrationArrayOutputWithContext(ctx context.Context) ApiIntegrationArrayOutput {
	return o
}

func (o ApiIntegrationArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*ApiIntegration] {
	return pulumix.Output[[]*ApiIntegration]{
		OutputState: o.OutputState,
	}
}

func (o ApiIntegrationArrayOutput) Index(i pulumi.IntInput) ApiIntegrationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApiIntegration {
		return vs[0].([]*ApiIntegration)[vs[1].(int)]
	}).(ApiIntegrationOutput)
}

type ApiIntegrationMapOutput struct{ *pulumi.OutputState }

func (ApiIntegrationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApiIntegration)(nil)).Elem()
}

func (o ApiIntegrationMapOutput) ToApiIntegrationMapOutput() ApiIntegrationMapOutput {
	return o
}

func (o ApiIntegrationMapOutput) ToApiIntegrationMapOutputWithContext(ctx context.Context) ApiIntegrationMapOutput {
	return o
}

func (o ApiIntegrationMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*ApiIntegration] {
	return pulumix.Output[map[string]*ApiIntegration]{
		OutputState: o.OutputState,
	}
}

func (o ApiIntegrationMapOutput) MapIndex(k pulumi.StringInput) ApiIntegrationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApiIntegration {
		return vs[0].(map[string]*ApiIntegration)[vs[1].(string)]
	}).(ApiIntegrationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApiIntegrationInput)(nil)).Elem(), &ApiIntegration{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApiIntegrationArrayInput)(nil)).Elem(), ApiIntegrationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApiIntegrationMapInput)(nil)).Elem(), ApiIntegrationMap{})
	pulumi.RegisterOutputType(ApiIntegrationOutput{})
	pulumi.RegisterOutputType(ApiIntegrationArrayOutput{})
	pulumi.RegisterOutputType(ApiIntegrationMapOutput{})
}
