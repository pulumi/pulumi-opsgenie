# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AlertPolicyFilterArgs',
    'AlertPolicyFilterConditionArgs',
    'AlertPolicyResponderArgs',
    'AlertPolicyTimeRestrictionArgs',
    'AlertPolicyTimeRestrictionRestrictionArgs',
    'ApiIntegrationResponderArgs',
    'EmailIntegrationResponderArgs',
    'EscalationRepeatArgs',
    'EscalationRuleArgs',
    'EscalationRuleRecipientArgs',
    'IncidentTemplateStakeholderPropertyArgs',
    'IntegrationActionAcknowledgeArgs',
    'IntegrationActionAcknowledgeFilterArgs',
    'IntegrationActionAcknowledgeFilterConditionArgs',
    'IntegrationActionAddNoteArgs',
    'IntegrationActionAddNoteFilterArgs',
    'IntegrationActionAddNoteFilterConditionArgs',
    'IntegrationActionCloseArgs',
    'IntegrationActionCloseFilterArgs',
    'IntegrationActionCloseFilterConditionArgs',
    'IntegrationActionCreateArgs',
    'IntegrationActionCreateFilterArgs',
    'IntegrationActionCreateFilterConditionArgs',
    'IntegrationActionCreateResponderArgs',
    'IntegrationActionIgnoreArgs',
    'IntegrationActionIgnoreFilterArgs',
    'IntegrationActionIgnoreFilterConditionArgs',
    'MaintenanceRuleArgs',
    'MaintenanceRuleEntityArgs',
    'MaintenanceTimeArgs',
    'NotificationPolicyAutoCloseActionArgs',
    'NotificationPolicyAutoCloseActionDurationArgs',
    'NotificationPolicyAutoRestartActionArgs',
    'NotificationPolicyAutoRestartActionDurationArgs',
    'NotificationPolicyDeDuplicationActionArgs',
    'NotificationPolicyDeDuplicationActionDurationArgs',
    'NotificationPolicyDelayActionArgs',
    'NotificationPolicyDelayActionDurationArgs',
    'NotificationPolicyFilterArgs',
    'NotificationPolicyFilterConditionArgs',
    'NotificationPolicyTimeRestrictionArgs',
    'NotificationPolicyTimeRestrictionRestrictionArgs',
    'NotificationRuleCriteriaArgs',
    'NotificationRuleCriteriaConditionArgs',
    'NotificationRuleRepeatArgs',
    'NotificationRuleScheduleArgs',
    'NotificationRuleStepArgs',
    'NotificationRuleStepContactArgs',
    'NotificationRuleTimeRestrictionArgs',
    'NotificationRuleTimeRestrictionRestrictionArgs',
    'ScheduleRotationParticipantArgs',
    'ScheduleRotationTimeRestrictionArgs',
    'ScheduleRotationTimeRestrictionRestrictionArgs',
    'ServiceIncidentRuleIncidentRuleArgs',
    'ServiceIncidentRuleIncidentRuleConditionArgs',
    'ServiceIncidentRuleIncidentRuleIncidentPropertyArgs',
    'ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderPropertyArgs',
    'TeamMemberArgs',
    'TeamRoutingRuleCriteriaArgs',
    'TeamRoutingRuleCriteriaConditionArgs',
    'TeamRoutingRuleNotifyArgs',
    'TeamRoutingRuleTimeRestrictionArgs',
    'TeamRoutingRuleTimeRestrictionRestrictionArgs',
    'UserUserAddressArgs',
    'GetEscalationRepeatArgs',
    'GetEscalationRuleArgs',
    'GetEscalationRuleRecipientArgs',
    'GetTeamMemberArgs',
]

@pulumi.input_type
class AlertPolicyFilterArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyFilterConditionArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlertPolicyFilterConditionArgs']]] conditions: Conditions applied to filter. This is a block, structure is documented below.
        :param pulumi.Input[str] type: Type of responder. Acceptable values are: `user` or `team`
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyFilterConditionArgs']]]]:
        """
        Conditions applied to filter. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyFilterConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of responder. Acceptable values are: `user` or `team`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AlertPolicyFilterConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] field: Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`
        :param pulumi.Input[str] operation: It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        :param pulumi.Input[str] expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param pulumi.Input[str] key: If `field` is set as extra-properties, key could be used for key-value pair
        :param pulumi.Input[bool] not_: Indicates behaviour of the given operation. Default:`false`
        :param pulumi.Input[int] order: Order of the condition in conditions list
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        """
        It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        If `field` is set as extra-properties, key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates behaviour of the given operation. Default:`false`
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class AlertPolicyResponderArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the responder
        :param pulumi.Input[str] type: Type of responder. Acceptable values are: `user` or `team`
        :param pulumi.Input[str] name: Name of the responder
        :param pulumi.Input[str] username: Username of the responder
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the responder
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of responder. Acceptable values are: `user` or `team`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the responder
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username of the responder
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class AlertPolicyTimeRestrictionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyTimeRestrictionRestrictionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Type of responder. Acceptable values are: `user` or `team`
        :param pulumi.Input[Sequence[pulumi.Input['AlertPolicyTimeRestrictionRestrictionArgs']]] restrictions: List of days and hours definitions for field type = `weekday-and-time-of-day`. This is a block, structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of responder. Acceptable values are: `user` or `team`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyTimeRestrictionRestrictionArgs']]]]:
        """
        List of days and hours definitions for field type = `weekday-and-time-of-day`. This is a block, structure is documented below.
        """
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyTimeRestrictionRestrictionArgs']]]]):
        pulumi.set(self, "restrictions", value)


@pulumi.input_type
class AlertPolicyTimeRestrictionRestrictionArgs:
    def __init__(__self__, *,
                 end_day: pulumi.Input[str],
                 end_hour: pulumi.Input[int],
                 end_min: pulumi.Input[int],
                 start_day: pulumi.Input[str],
                 start_hour: pulumi.Input[int],
                 start_min: pulumi.Input[int]):
        """
        :param pulumi.Input[str] end_day: Ending day of restriction (eg. `wednesday`)
        :param pulumi.Input[int] end_hour: Ending hour of restriction.
        :param pulumi.Input[int] end_min: Ending minute of restriction on defined `end_hour`
        :param pulumi.Input[str] start_day: Starting day of restriction (eg. `monday`)
        :param pulumi.Input[int] start_hour: Starting hour of restriction.
        :param pulumi.Input[int] start_min: Staring minute of restriction on defined `start_hour`
        """
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> pulumi.Input[str]:
        """
        Ending day of restriction (eg. `wednesday`)
        """
        return pulumi.get(self, "end_day")

    @end_day.setter
    def end_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_day", value)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> pulumi.Input[int]:
        """
        Ending hour of restriction.
        """
        return pulumi.get(self, "end_hour")

    @end_hour.setter
    def end_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_hour", value)

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> pulumi.Input[int]:
        """
        Ending minute of restriction on defined `end_hour`
        """
        return pulumi.get(self, "end_min")

    @end_min.setter
    def end_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_min", value)

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> pulumi.Input[str]:
        """
        Starting day of restriction (eg. `monday`)
        """
        return pulumi.get(self, "start_day")

    @start_day.setter
    def start_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_day", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[int]:
        """
        Starting hour of restriction.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> pulumi.Input[int]:
        """
        Staring minute of restriction on defined `start_hour`
        """
        return pulumi.get(self, "start_min")

    @start_min.setter
    def start_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_min", value)


@pulumi.input_type
class ApiIntegrationResponderArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the responder.
        :param pulumi.Input[str] type: The responder type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The responder type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EmailIntegrationResponderArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the responder.
        :param pulumi.Input[str] type: The responder type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The responder type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EscalationRepeatArgs:
    def __init__(__self__, *,
                 close_alert_after_all: Optional[pulumi.Input[bool]] = None,
                 count: Optional[pulumi.Input[int]] = None,
                 reset_recipient_states: Optional[pulumi.Input[bool]] = None,
                 wait_interval: Optional[pulumi.Input[int]] = None):
        if close_alert_after_all is not None:
            pulumi.set(__self__, "close_alert_after_all", close_alert_after_all)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if reset_recipient_states is not None:
            pulumi.set(__self__, "reset_recipient_states", reset_recipient_states)
        if wait_interval is not None:
            pulumi.set(__self__, "wait_interval", wait_interval)

    @property
    @pulumi.getter(name="closeAlertAfterAll")
    def close_alert_after_all(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "close_alert_after_all")

    @close_alert_after_all.setter
    def close_alert_after_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "close_alert_after_all", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="resetRecipientStates")
    def reset_recipient_states(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "reset_recipient_states")

    @reset_recipient_states.setter
    def reset_recipient_states(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reset_recipient_states", value)

    @property
    @pulumi.getter(name="waitInterval")
    def wait_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "wait_interval")

    @wait_interval.setter
    def wait_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_interval", value)


@pulumi.input_type
class EscalationRuleArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 delay: pulumi.Input[int],
                 notify_type: pulumi.Input[str],
                 recipients: pulumi.Input[Sequence[pulumi.Input['EscalationRuleRecipientArgs']]]):
        """
        :param pulumi.Input[str] condition: The condition for notifying the recipient of escalation rule that is based on the alert state. Possible values are: `if-not-acked` and `if-not-closed`. Default: `if-not-acked`
        :param pulumi.Input[int] delay: Time delay of the escalation rule, in minutes.
        :param pulumi.Input[str] notify_type: Recipient calculation logic for schedules. Possible values are:
        :param pulumi.Input[Sequence[pulumi.Input['EscalationRuleRecipientArgs']]] recipients: Object of schedule, team, or users which will be notified in escalation. The possible values for participants are: `user`, `schedule`, `team`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "notify_type", notify_type)
        pulumi.set(__self__, "recipients", recipients)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        The condition for notifying the recipient of escalation rule that is based on the alert state. Possible values are: `if-not-acked` and `if-not-closed`. Default: `if-not-acked`
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def delay(self) -> pulumi.Input[int]:
        """
        Time delay of the escalation rule, in minutes.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: pulumi.Input[int]):
        pulumi.set(self, "delay", value)

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> pulumi.Input[str]:
        """
        Recipient calculation logic for schedules. Possible values are:
        """
        return pulumi.get(self, "notify_type")

    @notify_type.setter
    def notify_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "notify_type", value)

    @property
    @pulumi.getter
    def recipients(self) -> pulumi.Input[Sequence[pulumi.Input['EscalationRuleRecipientArgs']]]:
        """
        Object of schedule, team, or users which will be notified in escalation. The possible values for participants are: `user`, `schedule`, `team`.
        """
        return pulumi.get(self, "recipients")

    @recipients.setter
    def recipients(self, value: pulumi.Input[Sequence[pulumi.Input['EscalationRuleRecipientArgs']]]):
        pulumi.set(self, "recipients", value)


@pulumi.input_type
class EscalationRuleRecipientArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the Opsgenie Escalation.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Opsgenie Escalation.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class IncidentTemplateStakeholderPropertyArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 enable: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] message: Message that is to be passed to audience that is generally used to provide a content information about the alert.
        :param pulumi.Input[str] description: Description that is generally used to provide a detailed information about the alert. This field must not be longer than 15000 characters.
        :param pulumi.Input[bool] enable: Option to enable stakeholder notifications.Default value is true.
        """
        pulumi.set(__self__, "message", message)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def message(self) -> pulumi.Input[str]:
        """
        Message that is to be passed to audience that is generally used to provide a content information about the alert.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[str]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description that is generally used to provide a detailed information about the alert. This field must not be longer than 15000 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Option to enable stakeholder notifications.Default value is true.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)


@pulumi.input_type
class IntegrationActionAcknowledgeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAcknowledgeFilterArgs']]]] = None,
                 note: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the integration action.
        :param pulumi.Input[str] alias: An identifier that is used for alert deduplication. Default: `{{alias}}`.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationActionAcknowledgeFilterArgs']]] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param pulumi.Input[str] note: Additional alert action note.
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        :param pulumi.Input[str] user: Owner of the execution for integration action.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An identifier that is used for alert deduplication. Default: `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAcknowledgeFilterArgs']]]]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAcknowledgeFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[str]]:
        """
        Additional alert action note.
        """
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "note", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class IntegrationActionAcknowledgeFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAcknowledgeFilterConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAcknowledgeFilterConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAcknowledgeFilterConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class IntegrationActionAcknowledgeFilterConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class IntegrationActionAddNoteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAddNoteFilterArgs']]]] = None,
                 note: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the integration action.
        :param pulumi.Input[str] alias: An identifier that is used for alert deduplication. Default: `{{alias}}`.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationActionAddNoteFilterArgs']]] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param pulumi.Input[str] note: Additional alert action note.
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        :param pulumi.Input[str] user: Owner of the execution for integration action.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An identifier that is used for alert deduplication. Default: `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAddNoteFilterArgs']]]]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAddNoteFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[str]]:
        """
        Additional alert action note.
        """
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "note", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class IntegrationActionAddNoteFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAddNoteFilterConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAddNoteFilterConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionAddNoteFilterConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class IntegrationActionAddNoteFilterConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class IntegrationActionCloseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCloseFilterArgs']]]] = None,
                 note: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the integration action.
        :param pulumi.Input[str] alias: An identifier that is used for alert deduplication. Default: `{{alias}}`.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationActionCloseFilterArgs']]] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param pulumi.Input[str] note: Additional alert action note.
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        :param pulumi.Input[str] user: Owner of the execution for integration action.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An identifier that is used for alert deduplication. Default: `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCloseFilterArgs']]]]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCloseFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[str]]:
        """
        Additional alert action note.
        """
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "note", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class IntegrationActionCloseFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCloseFilterConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCloseFilterConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCloseFilterConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class IntegrationActionCloseFilterConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class IntegrationActionCreateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alert_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 alias: Optional[pulumi.Input[str]] = None,
                 append_attachments: Optional[pulumi.Input[bool]] = None,
                 custom_priority: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entity: Optional[pulumi.Input[str]] = None,
                 extra_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateFilterArgs']]]] = None,
                 ignore_alert_actions_from_payload: Optional[pulumi.Input[bool]] = None,
                 ignore_extra_properties_from_payload: Optional[pulumi.Input[bool]] = None,
                 ignore_responders_from_payload: Optional[pulumi.Input[bool]] = None,
                 ignore_tags_from_payload: Optional[pulumi.Input[bool]] = None,
                 ignore_teams_from_payload: Optional[pulumi.Input[bool]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 note: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 responders: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateResponderArgs']]]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the integration action.
        :param pulumi.Input[str] alias: An identifier that is used for alert deduplication. Default: `{{alias}}`.
        :param pulumi.Input[str] custom_priority: Custom alert priority. e.g. ``{{message.substring(0,2)}}``
        :param pulumi.Input[str] description: Detailed description of the alert, anything that may not have fit in the `message` field.
        :param pulumi.Input[str] entity: The entity the alert is related to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] extra_properties: Set of user defined properties specified as a map.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateFilterArgs']]] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param pulumi.Input[bool] ignore_responders_from_payload: If enabled, the integration will ignore responders sent in request payloads.
        :param pulumi.Input[bool] ignore_teams_from_payload: If enabled, the integration will ignore teams sent in request payloads.
        :param pulumi.Input[str] message: Alert text limited to 130 characters.
        :param pulumi.Input[str] note: Additional alert action note.
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param pulumi.Input[str] priority: Alert priority.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateResponderArgs']]] responders: User, schedule, teams or escalation names to calculate which users will receive notifications of the alert.
        :param pulumi.Input[str] source: User defined field to specify source of action.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Comma separated list of labels to be attached to the alert.
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        :param pulumi.Input[str] user: Owner of the execution for integration action.
        """
        pulumi.set(__self__, "name", name)
        if alert_actions is not None:
            pulumi.set(__self__, "alert_actions", alert_actions)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if append_attachments is not None:
            pulumi.set(__self__, "append_attachments", append_attachments)
        if custom_priority is not None:
            pulumi.set(__self__, "custom_priority", custom_priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if extra_properties is not None:
            pulumi.set(__self__, "extra_properties", extra_properties)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if ignore_alert_actions_from_payload is not None:
            pulumi.set(__self__, "ignore_alert_actions_from_payload", ignore_alert_actions_from_payload)
        if ignore_extra_properties_from_payload is not None:
            pulumi.set(__self__, "ignore_extra_properties_from_payload", ignore_extra_properties_from_payload)
        if ignore_responders_from_payload is not None:
            pulumi.set(__self__, "ignore_responders_from_payload", ignore_responders_from_payload)
        if ignore_tags_from_payload is not None:
            pulumi.set(__self__, "ignore_tags_from_payload", ignore_tags_from_payload)
        if ignore_teams_from_payload is not None:
            pulumi.set(__self__, "ignore_teams_from_payload", ignore_teams_from_payload)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if responders is not None:
            pulumi.set(__self__, "responders", responders)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="alertActions")
    def alert_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alert_actions")

    @alert_actions.setter
    def alert_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alert_actions", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An identifier that is used for alert deduplication. Default: `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="appendAttachments")
    def append_attachments(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "append_attachments")

    @append_attachments.setter
    def append_attachments(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "append_attachments", value)

    @property
    @pulumi.getter(name="customPriority")
    def custom_priority(self) -> Optional[pulumi.Input[str]]:
        """
        Custom alert priority. e.g. ``{{message.substring(0,2)}}``
        """
        return pulumi.get(self, "custom_priority")

    @custom_priority.setter
    def custom_priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_priority", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Detailed description of the alert, anything that may not have fit in the `message` field.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[str]]:
        """
        The entity the alert is related to.
        """
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity", value)

    @property
    @pulumi.getter(name="extraProperties")
    def extra_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Set of user defined properties specified as a map.
        """
        return pulumi.get(self, "extra_properties")

    @extra_properties.setter
    def extra_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_properties", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateFilterArgs']]]]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter(name="ignoreAlertActionsFromPayload")
    def ignore_alert_actions_from_payload(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ignore_alert_actions_from_payload")

    @ignore_alert_actions_from_payload.setter
    def ignore_alert_actions_from_payload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_alert_actions_from_payload", value)

    @property
    @pulumi.getter(name="ignoreExtraPropertiesFromPayload")
    def ignore_extra_properties_from_payload(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ignore_extra_properties_from_payload")

    @ignore_extra_properties_from_payload.setter
    def ignore_extra_properties_from_payload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_extra_properties_from_payload", value)

    @property
    @pulumi.getter(name="ignoreRespondersFromPayload")
    def ignore_responders_from_payload(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, the integration will ignore responders sent in request payloads.
        """
        return pulumi.get(self, "ignore_responders_from_payload")

    @ignore_responders_from_payload.setter
    def ignore_responders_from_payload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_responders_from_payload", value)

    @property
    @pulumi.getter(name="ignoreTagsFromPayload")
    def ignore_tags_from_payload(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ignore_tags_from_payload")

    @ignore_tags_from_payload.setter
    def ignore_tags_from_payload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_tags_from_payload", value)

    @property
    @pulumi.getter(name="ignoreTeamsFromPayload")
    def ignore_teams_from_payload(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, the integration will ignore teams sent in request payloads.
        """
        return pulumi.get(self, "ignore_teams_from_payload")

    @ignore_teams_from_payload.setter
    def ignore_teams_from_payload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_teams_from_payload", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Alert text limited to 130 characters.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[str]]:
        """
        Additional alert action note.
        """
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "note", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        Alert priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def responders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateResponderArgs']]]]:
        """
        User, schedule, teams or escalation names to calculate which users will receive notifications of the alert.
        """
        return pulumi.get(self, "responders")

    @responders.setter
    def responders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateResponderArgs']]]]):
        pulumi.set(self, "responders", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        User defined field to specify source of action.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Comma separated list of labels to be attached to the alert.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class IntegrationActionCreateFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateFilterConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateFilterConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionCreateFilterConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class IntegrationActionCreateFilterConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class IntegrationActionCreateResponderArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The id of the responder.
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class IntegrationActionIgnoreArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionIgnoreFilterArgs']]]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the integration action.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationActionIgnoreFilterArgs']]] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        """
        pulumi.set(__self__, "name", name)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionIgnoreFilterArgs']]]]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionIgnoreFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class IntegrationActionIgnoreFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionIgnoreFilterConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The responder type - can be `escalation`, `team` or `user`.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionIgnoreFilterConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationActionIgnoreFilterConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class IntegrationActionIgnoreFilterConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class MaintenanceRuleArgs:
    def __init__(__self__, *,
                 entities: pulumi.Input[Sequence[pulumi.Input['MaintenanceRuleEntityArgs']]],
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MaintenanceRuleEntityArgs']]] entities: This field represents the entity that maintenance will be applied. Entity field takes two mandatory fields as id and type.
        :param pulumi.Input[str] state: State of rule that will be defined in maintenance and can take either enabled or disabled for policy type rules. This field has to be disabled for integration type entity rules.
        """
        pulumi.set(__self__, "entities", entities)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def entities(self) -> pulumi.Input[Sequence[pulumi.Input['MaintenanceRuleEntityArgs']]]:
        """
        This field represents the entity that maintenance will be applied. Entity field takes two mandatory fields as id and type.
        """
        return pulumi.get(self, "entities")

    @entities.setter
    def entities(self, value: pulumi.Input[Sequence[pulumi.Input['MaintenanceRuleEntityArgs']]]):
        pulumi.set(self, "entities", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of rule that will be defined in maintenance and can take either enabled or disabled for policy type rules. This field has to be disabled for integration type entity rules.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class MaintenanceRuleEntityArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the entity that maintenance will be applied.
        :param pulumi.Input[str] type: This parameter defines when the maintenance will be active. It can take one of for-5-minutes, for-30-minutes, for-1-hour, indefinitely or schedule.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the entity that maintenance will be applied.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter defines when the maintenance will be active. It can take one of for-5-minutes, for-30-minutes, for-1-hour, indefinitely or schedule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MaintenanceTimeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: This parameter defines when the maintenance will be active. It can take one of for-5-minutes, for-30-minutes, for-1-hour, indefinitely or schedule.
        :param pulumi.Input[str] end_date: This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        :param pulumi.Input[str] start_date: This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        pulumi.set(__self__, "type", type)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        This parameter defines when the maintenance will be active. It can take one of for-5-minutes, for-30-minutes, for-1-hour, indefinitely or schedule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class NotificationPolicyAutoCloseActionArgs:
    def __init__(__self__, *,
                 durations: pulumi.Input[Sequence[pulumi.Input['NotificationPolicyAutoCloseActionDurationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyAutoCloseActionDurationArgs']]] durations: Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        """
        pulumi.set(__self__, "durations", durations)

    @property
    @pulumi.getter
    def durations(self) -> pulumi.Input[Sequence[pulumi.Input['NotificationPolicyAutoCloseActionDurationArgs']]]:
        """
        Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    @durations.setter
    def durations(self, value: pulumi.Input[Sequence[pulumi.Input['NotificationPolicyAutoCloseActionDurationArgs']]]):
        pulumi.set(self, "durations", value)


@pulumi.input_type
class NotificationPolicyAutoCloseActionDurationArgs:
    def __init__(__self__, *,
                 time_amount: pulumi.Input[int],
                 time_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param pulumi.Input[str] time_unit: Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        pulumi.set(__self__, "time_amount", time_amount)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> pulumi.Input[int]:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @time_amount.setter
    def time_amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_amount", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_unit", value)


@pulumi.input_type
class NotificationPolicyAutoRestartActionArgs:
    def __init__(__self__, *,
                 durations: pulumi.Input[Sequence[pulumi.Input['NotificationPolicyAutoRestartActionDurationArgs']]],
                 max_repeat_count: pulumi.Input[int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyAutoRestartActionDurationArgs']]] durations: Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        :param pulumi.Input[int] max_repeat_count: How many times to repeat. This is a integer attribute.
        """
        pulumi.set(__self__, "durations", durations)
        pulumi.set(__self__, "max_repeat_count", max_repeat_count)

    @property
    @pulumi.getter
    def durations(self) -> pulumi.Input[Sequence[pulumi.Input['NotificationPolicyAutoRestartActionDurationArgs']]]:
        """
        Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    @durations.setter
    def durations(self, value: pulumi.Input[Sequence[pulumi.Input['NotificationPolicyAutoRestartActionDurationArgs']]]):
        pulumi.set(self, "durations", value)

    @property
    @pulumi.getter(name="maxRepeatCount")
    def max_repeat_count(self) -> pulumi.Input[int]:
        """
        How many times to repeat. This is a integer attribute.
        """
        return pulumi.get(self, "max_repeat_count")

    @max_repeat_count.setter
    def max_repeat_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_repeat_count", value)


@pulumi.input_type
class NotificationPolicyAutoRestartActionDurationArgs:
    def __init__(__self__, *,
                 time_amount: pulumi.Input[int],
                 time_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param pulumi.Input[str] time_unit: Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        pulumi.set(__self__, "time_amount", time_amount)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> pulumi.Input[int]:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @time_amount.setter
    def time_amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_amount", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_unit", value)


@pulumi.input_type
class NotificationPolicyDeDuplicationActionArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 de_duplication_action_type: pulumi.Input[str],
                 durations: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyDeDuplicationActionDurationArgs']]]] = None):
        """
        :param pulumi.Input[int] count: - Count
        :param pulumi.Input[str] de_duplication_action_type: Deduplication type. Possible values are: "value-based", "frequency-based"
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyDeDuplicationActionDurationArgs']]] durations: Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "de_duplication_action_type", de_duplication_action_type)
        if durations is not None:
            pulumi.set(__self__, "durations", durations)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        - Count
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="deDuplicationActionType")
    def de_duplication_action_type(self) -> pulumi.Input[str]:
        """
        Deduplication type. Possible values are: "value-based", "frequency-based"
        """
        return pulumi.get(self, "de_duplication_action_type")

    @de_duplication_action_type.setter
    def de_duplication_action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "de_duplication_action_type", value)

    @property
    @pulumi.getter
    def durations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyDeDuplicationActionDurationArgs']]]]:
        """
        Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    @durations.setter
    def durations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyDeDuplicationActionDurationArgs']]]]):
        pulumi.set(self, "durations", value)


@pulumi.input_type
class NotificationPolicyDeDuplicationActionDurationArgs:
    def __init__(__self__, *,
                 time_amount: pulumi.Input[int],
                 time_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param pulumi.Input[str] time_unit: Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        pulumi.set(__self__, "time_amount", time_amount)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> pulumi.Input[int]:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @time_amount.setter
    def time_amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_amount", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_unit", value)


@pulumi.input_type
class NotificationPolicyDelayActionArgs:
    def __init__(__self__, *,
                 delay_option: pulumi.Input[str],
                 durations: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyDelayActionDurationArgs']]]] = None,
                 until_hour: Optional[pulumi.Input[int]] = None,
                 until_minute: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] delay_option: Defines until what day to delay or for what duration. Possible values are: `for-duration`, `next-time`, `next-weekday`, `next-monday`, `next-tuesday`, `next-wednesday`, `next-thursday`, `next-friday`, `next-saturday`, `next-sunday`
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyDelayActionDurationArgs']]] durations: Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        :param pulumi.Input[int] until_hour: Until what hour notifications will be delayed. If `delay_option` is set to antyhing else then `for-duration` this has to be set.
        :param pulumi.Input[int] until_minute: Until what minute on `until_hour` notifications will be delayed. If `delay_option` is set to antyhing else then `for-duration` this has to be set.
        """
        pulumi.set(__self__, "delay_option", delay_option)
        if durations is not None:
            pulumi.set(__self__, "durations", durations)
        if until_hour is not None:
            pulumi.set(__self__, "until_hour", until_hour)
        if until_minute is not None:
            pulumi.set(__self__, "until_minute", until_minute)

    @property
    @pulumi.getter(name="delayOption")
    def delay_option(self) -> pulumi.Input[str]:
        """
        Defines until what day to delay or for what duration. Possible values are: `for-duration`, `next-time`, `next-weekday`, `next-monday`, `next-tuesday`, `next-wednesday`, `next-thursday`, `next-friday`, `next-saturday`, `next-sunday`
        """
        return pulumi.get(self, "delay_option")

    @delay_option.setter
    def delay_option(self, value: pulumi.Input[str]):
        pulumi.set(self, "delay_option", value)

    @property
    @pulumi.getter
    def durations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyDelayActionDurationArgs']]]]:
        """
        Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    @durations.setter
    def durations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyDelayActionDurationArgs']]]]):
        pulumi.set(self, "durations", value)

    @property
    @pulumi.getter(name="untilHour")
    def until_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Until what hour notifications will be delayed. If `delay_option` is set to antyhing else then `for-duration` this has to be set.
        """
        return pulumi.get(self, "until_hour")

    @until_hour.setter
    def until_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "until_hour", value)

    @property
    @pulumi.getter(name="untilMinute")
    def until_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Until what minute on `until_hour` notifications will be delayed. If `delay_option` is set to antyhing else then `for-duration` this has to be set.
        """
        return pulumi.get(self, "until_minute")

    @until_minute.setter
    def until_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "until_minute", value)


@pulumi.input_type
class NotificationPolicyDelayActionDurationArgs:
    def __init__(__self__, *,
                 time_amount: pulumi.Input[int],
                 time_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param pulumi.Input[str] time_unit: Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        pulumi.set(__self__, "time_amount", time_amount)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> pulumi.Input[int]:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @time_amount.setter
    def time_amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_amount", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_unit", value)


@pulumi.input_type
class NotificationPolicyFilterArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyFilterConditionArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyFilterConditionArgs']]] conditions: Conditions applied to filter. This is a block, structure is documented below.
        :param pulumi.Input[str] type: Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: `time-of-day`, `weekday-and-time-of-day`
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyFilterConditionArgs']]]]:
        """
        Conditions applied to filter. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyFilterConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: `time-of-day`, `weekday-and-time-of-day`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class NotificationPolicyFilterConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] field: Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`
        :param pulumi.Input[str] operation: It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        :param pulumi.Input[str] expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param pulumi.Input[str] key: If `field` is set as extra-properties, key could be used for key-value pair
        :param pulumi.Input[bool] not_: Indicates behaviour of the given operation. Default: `false`
        :param pulumi.Input[int] order: Order of the condition in conditions list
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        """
        It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        If `field` is set as extra-properties, key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates behaviour of the given operation. Default: `false`
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class NotificationPolicyTimeRestrictionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyTimeRestrictionRestrictionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: `time-of-day`, `weekday-and-time-of-day`
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPolicyTimeRestrictionRestrictionArgs']]] restrictions: List of days and hours definitions for field type = `weekday-and-time-of-day`. This is a block, structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: `time-of-day`, `weekday-and-time-of-day`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyTimeRestrictionRestrictionArgs']]]]:
        """
        List of days and hours definitions for field type = `weekday-and-time-of-day`. This is a block, structure is documented below.
        """
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyTimeRestrictionRestrictionArgs']]]]):
        pulumi.set(self, "restrictions", value)


@pulumi.input_type
class NotificationPolicyTimeRestrictionRestrictionArgs:
    def __init__(__self__, *,
                 end_day: pulumi.Input[str],
                 end_hour: pulumi.Input[int],
                 end_min: pulumi.Input[int],
                 start_day: pulumi.Input[str],
                 start_hour: pulumi.Input[int],
                 start_min: pulumi.Input[int]):
        """
        :param pulumi.Input[str] end_day: Ending day of restriction (eg. `wednesday`)
        :param pulumi.Input[int] end_hour: Ending hour of restriction.
        :param pulumi.Input[int] end_min: Ending minute of restriction on defined `end_hour`
        :param pulumi.Input[str] start_day: Starting day of restriction (eg. `monday`)
        :param pulumi.Input[int] start_hour: Starting hour of restriction.
        :param pulumi.Input[int] start_min: Staring minute of restriction on defined `start_hour`
        """
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> pulumi.Input[str]:
        """
        Ending day of restriction (eg. `wednesday`)
        """
        return pulumi.get(self, "end_day")

    @end_day.setter
    def end_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_day", value)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> pulumi.Input[int]:
        """
        Ending hour of restriction.
        """
        return pulumi.get(self, "end_hour")

    @end_hour.setter
    def end_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_hour", value)

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> pulumi.Input[int]:
        """
        Ending minute of restriction on defined `end_hour`
        """
        return pulumi.get(self, "end_min")

    @end_min.setter
    def end_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_min", value)

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> pulumi.Input[str]:
        """
        Starting day of restriction (eg. `monday`)
        """
        return pulumi.get(self, "start_day")

    @start_day.setter
    def start_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_day", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[int]:
        """
        Starting hour of restriction.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> pulumi.Input[int]:
        """
        Staring minute of restriction on defined `start_hour`
        """
        return pulumi.get(self, "start_min")

    @start_min.setter
    def start_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_min", value)


@pulumi.input_type
class NotificationRuleCriteriaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationRuleCriteriaConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        :param pulumi.Input[Sequence[pulumi.Input['NotificationRuleCriteriaConditionArgs']]] conditions: Defines the fields and values when the condition applies
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationRuleCriteriaConditionArgs']]]]:
        """
        Defines the fields and values when the condition applies
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationRuleCriteriaConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class NotificationRuleCriteriaConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] field: Possible values: "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        :param pulumi.Input[str] operation: Possible values: "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace
        :param pulumi.Input[str] key: If 'field' is set as 'extra-properties', key could be used for key-value pair
        :param pulumi.Input[bool] not_: Indicates behaviour of the given operation. Default value is false
        :param pulumi.Input[int] order: Order of the condition in conditions list
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        Possible values: "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        """
        Possible values: "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        If 'field' is set as 'extra-properties', key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates behaviour of the given operation. Default value is false
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class NotificationRuleRepeatArgs:
    def __init__(__self__, *,
                 loop_after: pulumi.Input[int],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Defined if this step is enabled. Default: true
        """
        pulumi.set(__self__, "loop_after", loop_after)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="loopAfter")
    def loop_after(self) -> pulumi.Input[int]:
        return pulumi.get(self, "loop_after")

    @loop_after.setter
    def loop_after(self, value: pulumi.Input[int]):
        pulumi.set(self, "loop_after", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defined if this step is enabled. Default: true
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class NotificationRuleScheduleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the notification policy
        :param pulumi.Input[str] type: Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the notification policy
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class NotificationRuleStepArgs:
    def __init__(__self__, *,
                 contacts: pulumi.Input[Sequence[pulumi.Input['NotificationRuleStepContactArgs']]],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 send_after: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NotificationRuleStepContactArgs']]] contacts: Defines the contact that notification will be sent to. This is a block, structure is documented below.
        :param pulumi.Input[bool] enabled: Defined if this step is enabled. Default: true
        :param pulumi.Input[int] send_after: Minute time period notification will be sent after.
        """
        pulumi.set(__self__, "contacts", contacts)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if send_after is not None:
            pulumi.set(__self__, "send_after", send_after)

    @property
    @pulumi.getter
    def contacts(self) -> pulumi.Input[Sequence[pulumi.Input['NotificationRuleStepContactArgs']]]:
        """
        Defines the contact that notification will be sent to. This is a block, structure is documented below.
        """
        return pulumi.get(self, "contacts")

    @contacts.setter
    def contacts(self, value: pulumi.Input[Sequence[pulumi.Input['NotificationRuleStepContactArgs']]]):
        pulumi.set(self, "contacts", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defined if this step is enabled. Default: true
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="sendAfter")
    def send_after(self) -> Optional[pulumi.Input[int]]:
        """
        Minute time period notification will be sent after.
        """
        return pulumi.get(self, "send_after")

    @send_after.setter
    def send_after(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "send_after", value)


@pulumi.input_type
class NotificationRuleStepContactArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 to: pulumi.Input[str]):
        """
        :param pulumi.Input[str] method: Contact method. Possible values: "email", "sms", "voice", "mobile"
        :param pulumi.Input[str] to: Address of a given method (eg. phone number for sms/voice or email address for email)
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Contact method. Possible values: "email", "sms", "voice", "mobile"
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[str]:
        """
        Address of a given method (eg. phone number for sms/voice or email address for email)
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[str]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class NotificationRuleTimeRestrictionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationRuleTimeRestrictionRestrictionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationRuleTimeRestrictionRestrictionArgs']]]]:
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationRuleTimeRestrictionRestrictionArgs']]]]):
        pulumi.set(self, "restrictions", value)


@pulumi.input_type
class NotificationRuleTimeRestrictionRestrictionArgs:
    def __init__(__self__, *,
                 end_day: pulumi.Input[str],
                 end_hour: pulumi.Input[int],
                 end_min: pulumi.Input[int],
                 start_day: pulumi.Input[str],
                 start_hour: pulumi.Input[int],
                 start_min: pulumi.Input[int]):
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_day")

    @end_day.setter
    def end_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_day", value)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> pulumi.Input[int]:
        return pulumi.get(self, "end_hour")

    @end_hour.setter
    def end_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_hour", value)

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "end_min")

    @end_min.setter
    def end_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_min", value)

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_day")

    @start_day.setter
    def start_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_day", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[int]:
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "start_min")

    @start_min.setter
    def start_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_min", value)


@pulumi.input_type
class ScheduleRotationParticipantArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The responder type.
        :param pulumi.Input[str] id: The id of the responder.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The responder type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ScheduleRotationTimeRestrictionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleRotationTimeRestrictionRestrictionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: This parameter should be set to `time-of-day` or `weekday-and-time-of-day`.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleRotationTimeRestrictionRestrictionArgs']]] restrictions: It is a restriction object which is described below. This can be used only if time restriction type is `weekday-and-time-of-day`.
        """
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        This parameter should be set to `time-of-day` or `weekday-and-time-of-day`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleRotationTimeRestrictionRestrictionArgs']]]]:
        """
        It is a restriction object which is described below. This can be used only if time restriction type is `weekday-and-time-of-day`.
        """
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleRotationTimeRestrictionRestrictionArgs']]]]):
        pulumi.set(self, "restrictions", value)


@pulumi.input_type
class ScheduleRotationTimeRestrictionRestrictionArgs:
    def __init__(__self__, *,
                 end_day: pulumi.Input[str],
                 end_hour: pulumi.Input[int],
                 end_min: pulumi.Input[int],
                 start_day: pulumi.Input[str],
                 start_hour: pulumi.Input[int],
                 start_min: pulumi.Input[int]):
        """
        :param pulumi.Input[str] end_day: Value of the day that frame will end.
        :param pulumi.Input[int] end_hour: Value of the hour that frame will end.
        :param pulumi.Input[int] end_min: Value of the minute that frame will end. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        :param pulumi.Input[str] start_day: Value of the day that frame will start.
        :param pulumi.Input[int] start_hour: Value of the hour that frame will start
        :param pulumi.Input[int] start_min: Value of the minute that frame will start. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> pulumi.Input[str]:
        """
        Value of the day that frame will end.
        """
        return pulumi.get(self, "end_day")

    @end_day.setter
    def end_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_day", value)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> pulumi.Input[int]:
        """
        Value of the hour that frame will end.
        """
        return pulumi.get(self, "end_hour")

    @end_hour.setter
    def end_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_hour", value)

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> pulumi.Input[int]:
        """
        Value of the minute that frame will end. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        return pulumi.get(self, "end_min")

    @end_min.setter
    def end_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_min", value)

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> pulumi.Input[str]:
        """
        Value of the day that frame will start.
        """
        return pulumi.get(self, "start_day")

    @start_day.setter
    def start_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_day", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[int]:
        """
        Value of the hour that frame will start
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> pulumi.Input[int]:
        """
        Value of the minute that frame will start. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        return pulumi.get(self, "start_min")

    @start_min.setter
    def start_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_min", value)


@pulumi.input_type
class ServiceIncidentRuleIncidentRuleArgs:
    def __init__(__self__, *,
                 incident_properties: pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleIncidentPropertyArgs']]],
                 condition_match_type: Optional[pulumi.Input[str]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleIncidentPropertyArgs']]] incident_properties: Properties for incident rule. This is a block, structure is documented below.
        :param pulumi.Input[str] condition_match_type: A Condition type, supported types are: "match-all", "match-any-condition", "match-all-conditions". Default: "match-all"
        :param pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleConditionArgs']]] conditions: Conditions applied to incident. This is a block, structure is documented below.
        """
        pulumi.set(__self__, "incident_properties", incident_properties)
        if condition_match_type is not None:
            pulumi.set(__self__, "condition_match_type", condition_match_type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter(name="incidentProperties")
    def incident_properties(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleIncidentPropertyArgs']]]:
        """
        Properties for incident rule. This is a block, structure is documented below.
        """
        return pulumi.get(self, "incident_properties")

    @incident_properties.setter
    def incident_properties(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleIncidentPropertyArgs']]]):
        pulumi.set(self, "incident_properties", value)

    @property
    @pulumi.getter(name="conditionMatchType")
    def condition_match_type(self) -> Optional[pulumi.Input[str]]:
        """
        A Condition type, supported types are: "match-all", "match-any-condition", "match-all-conditions". Default: "match-all"
        """
        return pulumi.get(self, "condition_match_type")

    @condition_match_type.setter
    def condition_match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition_match_type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleConditionArgs']]]]:
        """
        Conditions applied to incident. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class ServiceIncidentRuleIncidentRuleConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] field: Specifies which alert field will be used in condition. Possible values are "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        :param pulumi.Input[str] operation: It is the operation that will be executed for the given field and key. Possible operations are "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace".
        :param pulumi.Input[str] expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param pulumi.Input[bool] not_: Indicates behaviour of the given operation. Default: false
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        Specifies which alert field will be used in condition. Possible values are "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        """
        It is the operation that will be executed for the given field and key. Possible operations are "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace".
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates behaviour of the given operation. Default: false
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)


@pulumi.input_type
class ServiceIncidentRuleIncidentRuleIncidentPropertyArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[str],
                 priority: pulumi.Input[str],
                 stakeholder_properties: pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderPropertyArgs']]],
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] message: Message that is to be passed to audience that is generally used to provide a content information about the alert.
        :param pulumi.Input[str] priority: Priority level of the alert. Possible values are P1, P2, P3, P4 and P5
        :param pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderPropertyArgs']]] stakeholder_properties: DEtails about stakeholders for this rule. This is a block, structure is documented below.
        :param pulumi.Input[str] description: Description that is generally used to provide a detailed information about the alert.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] details: Map of key-value pairs to use as custom properties of the alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags of the alert.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "stakeholder_properties", stakeholder_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def message(self) -> pulumi.Input[str]:
        """
        Message that is to be passed to audience that is generally used to provide a content information about the alert.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[str]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[str]:
        """
        Priority level of the alert. Possible values are P1, P2, P3, P4 and P5
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[str]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="stakeholderProperties")
    def stakeholder_properties(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderPropertyArgs']]]:
        """
        DEtails about stakeholders for this rule. This is a block, structure is documented below.
        """
        return pulumi.get(self, "stakeholder_properties")

    @stakeholder_properties.setter
    def stakeholder_properties(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderPropertyArgs']]]):
        pulumi.set(self, "stakeholder_properties", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description that is generally used to provide a detailed information about the alert.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of key-value pairs to use as custom properties of the alert.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Tags of the alert.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderPropertyArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 enable: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] message: Message that is to be passed to audience that is generally used to provide a content information about the alert.
        :param pulumi.Input[str] description: Description that is generally used to provide a detailed information about the alert.
        :param pulumi.Input[bool] enable: Option to enable stakeholder notifications.Default value is true.
        """
        pulumi.set(__self__, "message", message)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def message(self) -> pulumi.Input[str]:
        """
        Message that is to be passed to audience that is generally used to provide a content information about the alert.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[str]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description that is generally used to provide a detailed information about the alert.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Option to enable stakeholder notifications.Default value is true.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)


@pulumi.input_type
class TeamMemberArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The UUID for the member to add to this Team.
        :param pulumi.Input[str] role: The role for the user within the Team - can be either 'admin' or 'user', defaults to 'user' if not set.
        """
        pulumi.set(__self__, "id", id)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The UUID for the member to add to this Team.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        The role for the user within the Team - can be either 'admin' or 'user', defaults to 'user' if not set.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


@pulumi.input_type
class TeamRoutingRuleCriteriaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['TeamRoutingRuleCriteriaConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Type of the operation will be applied on conditions. Should be one of match-all, match-any-condition or match-all-conditions.
        :param pulumi.Input[Sequence[pulumi.Input['TeamRoutingRuleCriteriaConditionArgs']]] conditions: List of conditions will be checked before applying team routing rule. This field declaration should be omitted if the criteria type is set to match-all.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the operation will be applied on conditions. Should be one of match-all, match-any-condition or match-all-conditions.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamRoutingRuleCriteriaConditionArgs']]]]:
        """
        List of conditions will be checked before applying team routing rule. This field declaration should be omitted if the criteria type is set to match-all.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamRoutingRuleCriteriaConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class TeamRoutingRuleCriteriaConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 operation: pulumi.Input[str],
                 expected_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 not_: Optional[pulumi.Input[bool]] = None,
                 order: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] field: Specifies which alert field will be used in condition. Possible values are message, alias, description, source, entity, tags, actions, extra-properties, recipients, teams or priority.
        :param pulumi.Input[str] operation: It is the operation that will be executed for the given field and key. Possible operations are matches, contains, starts-with, ends-with, equals, contains-key, contains-value, greater-than, less-than, is-empty and equals-ignore-whitespace.
        :param pulumi.Input[str] key: If field is set as extra-properties, key could be used for key-value pair.
        :param pulumi.Input[bool] not_: Indicates behaviour of the given operation. Default value is false.
        :param pulumi.Input[int] order: Order of the condition in conditions list.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        Specifies which alert field will be used in condition. Possible values are message, alias, description, source, entity, tags, actions, extra-properties, recipients, teams or priority.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        """
        It is the operation that will be executed for the given field and key. Possible operations are matches, contains, starts-with, ends-with, equals, contains-key, contains-value, greater-than, less-than, is-empty and equals-ignore-whitespace.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        If field is set as extra-properties, key could be used for key-value pair.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates behaviour of the given operation. Default value is false.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Order of the condition in conditions list.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class TeamRoutingRuleNotifyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the Opsgenie Team Routing Rule.
        :param pulumi.Input[str] name: Name of the team routing rule
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Opsgenie Team Routing Rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the team routing rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class TeamRoutingRuleTimeRestrictionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['TeamRoutingRuleTimeRestrictionRestrictionArgs']]]] = None):
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamRoutingRuleTimeRestrictionRestrictionArgs']]]]:
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamRoutingRuleTimeRestrictionRestrictionArgs']]]]):
        pulumi.set(self, "restrictions", value)


@pulumi.input_type
class TeamRoutingRuleTimeRestrictionRestrictionArgs:
    def __init__(__self__, *,
                 end_day: pulumi.Input[str],
                 end_hour: pulumi.Input[int],
                 end_min: pulumi.Input[int],
                 start_day: pulumi.Input[str],
                 start_hour: pulumi.Input[int],
                 start_min: pulumi.Input[int]):
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_day")

    @end_day.setter
    def end_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_day", value)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> pulumi.Input[int]:
        return pulumi.get(self, "end_hour")

    @end_hour.setter
    def end_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_hour", value)

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "end_min")

    @end_min.setter
    def end_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_min", value)

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_day")

    @start_day.setter
    def start_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_day", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[int]:
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "start_min")

    @start_min.setter
    def start_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_min", value)


@pulumi.input_type
class UserUserAddressArgs:
    def __init__(__self__, *,
                 city: pulumi.Input[str],
                 country: pulumi.Input[str],
                 line: pulumi.Input[str],
                 state: pulumi.Input[str],
                 zipcode: pulumi.Input[str]):
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "line", line)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "zipcode", zipcode)

    @property
    @pulumi.getter
    def city(self) -> pulumi.Input[str]:
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[str]):
        pulumi.set(self, "city", value)

    @property
    @pulumi.getter
    def country(self) -> pulumi.Input[str]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[str]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter
    def line(self) -> pulumi.Input[str]:
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: pulumi.Input[str]):
        pulumi.set(self, "line", value)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[str]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[str]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def zipcode(self) -> pulumi.Input[str]:
        return pulumi.get(self, "zipcode")

    @zipcode.setter
    def zipcode(self, value: pulumi.Input[str]):
        pulumi.set(self, "zipcode", value)


@pulumi.input_type
class GetEscalationRepeatArgs:
    def __init__(__self__, *,
                 close_alert_after_all: Optional[bool] = None,
                 count: Optional[int] = None,
                 reset_recipient_states: Optional[bool] = None,
                 wait_interval: Optional[int] = None):
        if close_alert_after_all is not None:
            pulumi.set(__self__, "close_alert_after_all", close_alert_after_all)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if reset_recipient_states is not None:
            pulumi.set(__self__, "reset_recipient_states", reset_recipient_states)
        if wait_interval is not None:
            pulumi.set(__self__, "wait_interval", wait_interval)

    @property
    @pulumi.getter(name="closeAlertAfterAll")
    def close_alert_after_all(self) -> Optional[bool]:
        return pulumi.get(self, "close_alert_after_all")

    @close_alert_after_all.setter
    def close_alert_after_all(self, value: Optional[bool]):
        pulumi.set(self, "close_alert_after_all", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="resetRecipientStates")
    def reset_recipient_states(self) -> Optional[bool]:
        return pulumi.get(self, "reset_recipient_states")

    @reset_recipient_states.setter
    def reset_recipient_states(self, value: Optional[bool]):
        pulumi.set(self, "reset_recipient_states", value)

    @property
    @pulumi.getter(name="waitInterval")
    def wait_interval(self) -> Optional[int]:
        return pulumi.get(self, "wait_interval")

    @wait_interval.setter
    def wait_interval(self, value: Optional[int]):
        pulumi.set(self, "wait_interval", value)


@pulumi.input_type
class GetEscalationRuleArgs:
    def __init__(__self__, *,
                 condition: str,
                 delay: int,
                 notify_type: str,
                 recipients: Sequence['GetEscalationRuleRecipientArgs']):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "notify_type", notify_type)
        pulumi.set(__self__, "recipients", recipients)

    @property
    @pulumi.getter
    def condition(self) -> str:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: str):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def delay(self) -> int:
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: int):
        pulumi.set(self, "delay", value)

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> str:
        return pulumi.get(self, "notify_type")

    @notify_type.setter
    def notify_type(self, value: str):
        pulumi.set(self, "notify_type", value)

    @property
    @pulumi.getter
    def recipients(self) -> Sequence['GetEscalationRuleRecipientArgs']:
        return pulumi.get(self, "recipients")

    @recipients.setter
    def recipients(self, value: Sequence['GetEscalationRuleRecipientArgs']):
        pulumi.set(self, "recipients", value)


@pulumi.input_type
class GetEscalationRuleRecipientArgs:
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Escalation.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Escalation.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GetTeamMemberArgs:
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 role: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Team.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Team.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[str]):
        pulumi.set(self, "role", value)


