# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from . import _utilities, _tables
from . import outputs

__all__ = [
    'AlertPolicyFilter',
    'AlertPolicyFilterCondition',
    'AlertPolicyResponder',
    'AlertPolicyTimeRestriction',
    'AlertPolicyTimeRestrictionRestriction',
    'ApiIntegrationResponder',
    'EmailIntegrationResponder',
    'EscalationRepeat',
    'EscalationRule',
    'EscalationRuleRecipient',
    'IncidentTemplateStakeholderProperty',
    'IntegrationActionAcknowledge',
    'IntegrationActionAcknowledgeFilter',
    'IntegrationActionAcknowledgeFilterCondition',
    'IntegrationActionAddNote',
    'IntegrationActionAddNoteFilter',
    'IntegrationActionAddNoteFilterCondition',
    'IntegrationActionClose',
    'IntegrationActionCloseFilter',
    'IntegrationActionCloseFilterCondition',
    'IntegrationActionCreate',
    'IntegrationActionCreateFilter',
    'IntegrationActionCreateFilterCondition',
    'IntegrationActionCreateResponder',
    'IntegrationActionIgnore',
    'IntegrationActionIgnoreFilter',
    'IntegrationActionIgnoreFilterCondition',
    'MaintenanceRule',
    'MaintenanceRuleEntity',
    'MaintenanceTime',
    'NotificationPolicyAutoCloseAction',
    'NotificationPolicyAutoCloseActionDuration',
    'NotificationPolicyAutoRestartAction',
    'NotificationPolicyAutoRestartActionDuration',
    'NotificationPolicyDeDuplicationAction',
    'NotificationPolicyDeDuplicationActionDuration',
    'NotificationPolicyDelayAction',
    'NotificationPolicyDelayActionDuration',
    'NotificationPolicyFilter',
    'NotificationPolicyFilterCondition',
    'NotificationPolicyTimeRestriction',
    'NotificationPolicyTimeRestrictionRestriction',
    'NotificationRuleCriteria',
    'NotificationRuleCriteriaCondition',
    'NotificationRuleRepeat',
    'NotificationRuleSchedule',
    'NotificationRuleStep',
    'NotificationRuleStepContact',
    'NotificationRuleTimeRestriction',
    'NotificationRuleTimeRestrictionRestriction',
    'ScheduleRotationParticipant',
    'ScheduleRotationTimeRestriction',
    'ScheduleRotationTimeRestrictionRestriction',
    'ServiceIncidentRuleIncidentRule',
    'ServiceIncidentRuleIncidentRuleCondition',
    'ServiceIncidentRuleIncidentRuleIncidentProperty',
    'ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty',
    'TeamMember',
    'TeamRoutingRuleCriteria',
    'TeamRoutingRuleCriteriaCondition',
    'TeamRoutingRuleNotify',
    'TeamRoutingRuleTimeRestriction',
    'TeamRoutingRuleTimeRestrictionRestriction',
    'UserUserAddress',
    'GetEscalationRepeatResult',
    'GetEscalationRuleResult',
    'GetEscalationRuleRecipientResult',
    'GetTeamMemberResult',
]

@pulumi.output_type
class AlertPolicyFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.AlertPolicyFilterCondition']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['AlertPolicyFilterConditionArgs'] conditions: Conditions applied to filter. This is a block, structure is documented below.
        :param str type: Type of responder. Acceptable values are: user or team
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.AlertPolicyFilterCondition']]:
        """
        Conditions applied to filter. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of responder. Acceptable values are: user or team
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyFilterCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param str field: Specifies which alert field will be used in condition. Possible values are "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        :param str operation: It is the operation that will be executed for the given field and key. Possible operations are "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace".
        :param str expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param str key: If `field` is set as extra-properties, key could be used for key-value pair
        :param bool not_: Indicates behaviour of the given operation. Default: false
        :param int order: Order of the condition in conditions list
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Specifies which alert field will be used in condition. Possible values are "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        It is the operation that will be executed for the given field and key. Possible operations are "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace".
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        If `field` is set as extra-properties, key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default: false
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyResponder(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str,
                 name: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str id: ID of the responder
        :param str type: Type of responder. Acceptable values are: user or team
        :param str name: Name of the responder
        :param str username: Username of the responder
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of responder. Acceptable values are: user or team
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the responder
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of the responder
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyTimeRestriction(dict):
    def __init__(__self__, *,
                 type: str,
                 restrictions: Optional[Sequence['outputs.AlertPolicyTimeRestrictionRestriction']] = None):
        """
        :param str type: Type of responder. Acceptable values are: user or team
        :param Sequence['AlertPolicyTimeRestrictionRestrictionArgs'] restrictions: List of days and hours definitions for field type = "weekday-and-time-of-day". This is a block, structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of responder. Acceptable values are: user or team
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.AlertPolicyTimeRestrictionRestriction']]:
        """
        List of days and hours definitions for field type = "weekday-and-time-of-day". This is a block, structure is documented below.
        """
        return pulumi.get(self, "restrictions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertPolicyTimeRestrictionRestriction(dict):
    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        """
        :param str end_day: Ending day of restriction (eg. "wednesday)
        :param int end_hour: Ending hour of restriction.
        :param int end_min: Ending minute of restriction on defined `end_hour`
        :param str start_day: Starting day of restriction (eg. "monday")
        :param int start_hour: Starting hour of restriction.
        :param int start_min: Staring minute of restriction on defined `start_hour`
        """
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        """
        Ending day of restriction (eg. "wednesday)
        """
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Ending hour of restriction.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Ending minute of restriction on defined `end_hour`
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        """
        Starting day of restriction (eg. "monday")
        """
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Starting hour of restriction.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Staring minute of restriction on defined `start_hour`
        """
        return pulumi.get(self, "start_min")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApiIntegrationResponder(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The id of the responder.
        :param str type: The responder type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EmailIntegrationResponder(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The id of the responder.
        :param str type: The responder type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EscalationRepeat(dict):
    def __init__(__self__, *,
                 close_alert_after_all: Optional[bool] = None,
                 count: Optional[int] = None,
                 reset_recipient_states: Optional[bool] = None,
                 wait_interval: Optional[int] = None):
        if close_alert_after_all is not None:
            pulumi.set(__self__, "close_alert_after_all", close_alert_after_all)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if reset_recipient_states is not None:
            pulumi.set(__self__, "reset_recipient_states", reset_recipient_states)
        if wait_interval is not None:
            pulumi.set(__self__, "wait_interval", wait_interval)

    @property
    @pulumi.getter(name="closeAlertAfterAll")
    def close_alert_after_all(self) -> Optional[bool]:
        return pulumi.get(self, "close_alert_after_all")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="resetRecipientStates")
    def reset_recipient_states(self) -> Optional[bool]:
        return pulumi.get(self, "reset_recipient_states")

    @property
    @pulumi.getter(name="waitInterval")
    def wait_interval(self) -> Optional[int]:
        return pulumi.get(self, "wait_interval")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EscalationRule(dict):
    def __init__(__self__, *,
                 condition: str,
                 delay: int,
                 notify_type: str,
                 recipients: Sequence['outputs.EscalationRuleRecipient']):
        """
        :param str condition: The condition for notifying the recipient of escalation rule that is based on the alert state. Possible values are: if-not-acked and if-not-closed. If not given, if-not-acked is used.
        :param int delay: Time delay of the escalation rule. This parameter takes an object that consists timeAmount field that takes time amount in minutes.
        :param str notify_type: Recipient calculation logic for schedules. Possible values are:
               ```python
               import pulumi
               ```
        :param Sequence['EscalationRuleRecipientArgs'] recipients: Object of schedule, team, or users which will be notified in escalation. The possible values for participants are: user, schedule, team.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "notify_type", notify_type)
        pulumi.set(__self__, "recipients", recipients)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        The condition for notifying the recipient of escalation rule that is based on the alert state. Possible values are: if-not-acked and if-not-closed. If not given, if-not-acked is used.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def delay(self) -> int:
        """
        Time delay of the escalation rule. This parameter takes an object that consists timeAmount field that takes time amount in minutes.
        """
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> str:
        """
        Recipient calculation logic for schedules. Possible values are:
        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "notify_type")

    @property
    @pulumi.getter
    def recipients(self) -> Sequence['outputs.EscalationRuleRecipient']:
        """
        Object of schedule, team, or users which will be notified in escalation. The possible values for participants are: user, schedule, team.
        """
        return pulumi.get(self, "recipients")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EscalationRuleRecipient(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Escalation.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Escalation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IncidentTemplateStakeholderProperty(dict):
    def __init__(__self__, *,
                 message: str,
                 description: Optional[str] = None,
                 enable: Optional[bool] = None):
        """
        :param str message: Message that is to be passed to audience that is generally used to provide a content information about the alert.
        :param str description: Description that is generally used to provide a detailed information about the alert. This field must not be longer than 15000 characters.
        :param bool enable: Option to enable stakeholder notifications.Default value is true.
        """
        pulumi.set(__self__, "message", message)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message that is to be passed to audience that is generally used to provide a content information about the alert.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description that is generally used to provide a detailed information about the alert. This field must not be longer than 15000 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Option to enable stakeholder notifications.Default value is true.
        """
        return pulumi.get(self, "enable")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionAcknowledge(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 filters: Optional[Sequence['outputs.IntegrationActionAcknowledgeFilter']] = None,
                 note: Optional[str] = None,
                 order: Optional[int] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param str alias: An identifier that is used for alert deduplication. Defaults to `{{alias}}`.
        :param Sequence['IntegrationActionAcknowledgeFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param str note: Integer value that defines in which order the action will be performed.
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        :param str type: The responder type - can be escalation, team or user.
        :param str user: Owner of the execution for integration action.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An identifier that is used for alert deduplication. Defaults to `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionAcknowledgeFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Integer value that defines in which order the action will be performed.
        """
        return pulumi.get(self, "note")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionAcknowledgeFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionAcknowledgeFilterCondition']] = None):
        """
        :param str type: The responder type - can be escalation, team or user.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionAcknowledgeFilterCondition']]:
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionAcknowledgeFilterCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionAddNote(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 filters: Optional[Sequence['outputs.IntegrationActionAddNoteFilter']] = None,
                 note: Optional[str] = None,
                 order: Optional[int] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param str alias: An identifier that is used for alert deduplication. Defaults to `{{alias}}`.
        :param Sequence['IntegrationActionAddNoteFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param str note: Integer value that defines in which order the action will be performed.
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        :param str type: The responder type - can be escalation, team or user.
        :param str user: Owner of the execution for integration action.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An identifier that is used for alert deduplication. Defaults to `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionAddNoteFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Integer value that defines in which order the action will be performed.
        """
        return pulumi.get(self, "note")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionAddNoteFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionAddNoteFilterCondition']] = None):
        """
        :param str type: The responder type - can be escalation, team or user.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionAddNoteFilterCondition']]:
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionAddNoteFilterCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionClose(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 filters: Optional[Sequence['outputs.IntegrationActionCloseFilter']] = None,
                 note: Optional[str] = None,
                 order: Optional[int] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param str alias: An identifier that is used for alert deduplication. Defaults to `{{alias}}`.
        :param Sequence['IntegrationActionCloseFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param str note: Integer value that defines in which order the action will be performed.
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        :param str type: The responder type - can be escalation, team or user.
        :param str user: Owner of the execution for integration action.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An identifier that is used for alert deduplication. Defaults to `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionCloseFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Integer value that defines in which order the action will be performed.
        """
        return pulumi.get(self, "note")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionCloseFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionCloseFilterCondition']] = None):
        """
        :param str type: The responder type - can be escalation, team or user.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionCloseFilterCondition']]:
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionCloseFilterCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionCreate(dict):
    def __init__(__self__, *,
                 name: str,
                 alert_actions: Optional[Sequence[str]] = None,
                 alias: Optional[str] = None,
                 append_attachments: Optional[bool] = None,
                 custom_priority: Optional[str] = None,
                 description: Optional[str] = None,
                 entity: Optional[str] = None,
                 extra_properties: Optional[Mapping[str, str]] = None,
                 filters: Optional[Sequence['outputs.IntegrationActionCreateFilter']] = None,
                 ignore_alert_actions_from_payload: Optional[bool] = None,
                 ignore_extra_properties_from_payload: Optional[bool] = None,
                 ignore_responders_from_payload: Optional[bool] = None,
                 ignore_tags_from_payload: Optional[bool] = None,
                 ignore_teams_from_payload: Optional[bool] = None,
                 message: Optional[str] = None,
                 note: Optional[str] = None,
                 order: Optional[int] = None,
                 priority: Optional[str] = None,
                 responders: Optional[Sequence['outputs.IntegrationActionCreateResponder']] = None,
                 source: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param str alias: An identifier that is used for alert deduplication. Defaults to `{{alias}}`.
        :param str custom_priority: Custom alert priority. e.g. {{message.substring(0,2)}}
        :param str description: Detailed description of the alert, anything that may not have fit in the `message` field.
        :param str entity: The entity the alert is related to.
        :param Mapping[str, str] extra_properties: Set of user defined properties specified as a map.
        :param Sequence['IntegrationActionCreateFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param bool ignore_responders_from_payload: If enabled, the integration will ignore responders sent in request payloads.
        :param bool ignore_teams_from_payload: If enabled, the integration will ignore teams sent in request payloads.
        :param str message: Alert text limited to 130 characters.
        :param str note: Integer value that defines in which order the action will be performed.
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        :param str priority: Alert priority.
        :param Sequence['IntegrationActionCreateResponderArgs'] responders: User, schedule, teams or escalation names to calculate which users will receive notifications of the alert.
        :param str source: User defined field to specify source of action.
        :param Sequence[str] tags: Comma separated list of labels to be attached to the alert.
        :param str type: The responder type - can be escalation, team or user.
        :param str user: Owner of the execution for integration action.
        """
        pulumi.set(__self__, "name", name)
        if alert_actions is not None:
            pulumi.set(__self__, "alert_actions", alert_actions)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if append_attachments is not None:
            pulumi.set(__self__, "append_attachments", append_attachments)
        if custom_priority is not None:
            pulumi.set(__self__, "custom_priority", custom_priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if extra_properties is not None:
            pulumi.set(__self__, "extra_properties", extra_properties)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if ignore_alert_actions_from_payload is not None:
            pulumi.set(__self__, "ignore_alert_actions_from_payload", ignore_alert_actions_from_payload)
        if ignore_extra_properties_from_payload is not None:
            pulumi.set(__self__, "ignore_extra_properties_from_payload", ignore_extra_properties_from_payload)
        if ignore_responders_from_payload is not None:
            pulumi.set(__self__, "ignore_responders_from_payload", ignore_responders_from_payload)
        if ignore_tags_from_payload is not None:
            pulumi.set(__self__, "ignore_tags_from_payload", ignore_tags_from_payload)
        if ignore_teams_from_payload is not None:
            pulumi.set(__self__, "ignore_teams_from_payload", ignore_teams_from_payload)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if responders is not None:
            pulumi.set(__self__, "responders", responders)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="alertActions")
    def alert_actions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "alert_actions")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An identifier that is used for alert deduplication. Defaults to `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="appendAttachments")
    def append_attachments(self) -> Optional[bool]:
        return pulumi.get(self, "append_attachments")

    @property
    @pulumi.getter(name="customPriority")
    def custom_priority(self) -> Optional[str]:
        """
        Custom alert priority. e.g. {{message.substring(0,2)}}
        """
        return pulumi.get(self, "custom_priority")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Detailed description of the alert, anything that may not have fit in the `message` field.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def entity(self) -> Optional[str]:
        """
        The entity the alert is related to.
        """
        return pulumi.get(self, "entity")

    @property
    @pulumi.getter(name="extraProperties")
    def extra_properties(self) -> Optional[Mapping[str, str]]:
        """
        Set of user defined properties specified as a map.
        """
        return pulumi.get(self, "extra_properties")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionCreateFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="ignoreAlertActionsFromPayload")
    def ignore_alert_actions_from_payload(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_alert_actions_from_payload")

    @property
    @pulumi.getter(name="ignoreExtraPropertiesFromPayload")
    def ignore_extra_properties_from_payload(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_extra_properties_from_payload")

    @property
    @pulumi.getter(name="ignoreRespondersFromPayload")
    def ignore_responders_from_payload(self) -> Optional[bool]:
        """
        If enabled, the integration will ignore responders sent in request payloads.
        """
        return pulumi.get(self, "ignore_responders_from_payload")

    @property
    @pulumi.getter(name="ignoreTagsFromPayload")
    def ignore_tags_from_payload(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_tags_from_payload")

    @property
    @pulumi.getter(name="ignoreTeamsFromPayload")
    def ignore_teams_from_payload(self) -> Optional[bool]:
        """
        If enabled, the integration will ignore teams sent in request payloads.
        """
        return pulumi.get(self, "ignore_teams_from_payload")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Alert text limited to 130 characters.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Integer value that defines in which order the action will be performed.
        """
        return pulumi.get(self, "note")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        Alert priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def responders(self) -> Optional[Sequence['outputs.IntegrationActionCreateResponder']]:
        """
        User, schedule, teams or escalation names to calculate which users will receive notifications of the alert.
        """
        return pulumi.get(self, "responders")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        User defined field to specify source of action.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Comma separated list of labels to be attached to the alert.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionCreateFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionCreateFilterCondition']] = None):
        """
        :param str type: The responder type - can be escalation, team or user.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionCreateFilterCondition']]:
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionCreateFilterCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionCreateResponder(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The id of the responder.
        :param str type: The responder type - can be escalation, team or user.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionIgnore(dict):
    def __init__(__self__, *,
                 name: str,
                 filters: Optional[Sequence['outputs.IntegrationActionIgnoreFilter']] = None,
                 order: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param Sequence['IntegrationActionIgnoreFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        :param str type: The responder type - can be escalation, team or user.
        """
        pulumi.set(__self__, "name", name)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionIgnoreFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionIgnoreFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionIgnoreFilterCondition']] = None):
        """
        :param str type: The responder type - can be escalation, team or user.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be escalation, team or user.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionIgnoreFilterCondition']]:
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationActionIgnoreFilterCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Defaults to `1`.
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MaintenanceRule(dict):
    def __init__(__self__, *,
                 entities: Sequence['outputs.MaintenanceRuleEntity'],
                 state: Optional[str] = None):
        """
        :param Sequence['MaintenanceRuleEntityArgs'] entities: This field represents the entity that maintenance will be applied. Entity field takes two mandatory fields as id and type.
        :param str state: State of rule that will be defined in maintenance and can take either enabled or disabled for policy type rules. This field has to be disabled for integration type entity rules.
        """
        pulumi.set(__self__, "entities", entities)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def entities(self) -> Sequence['outputs.MaintenanceRuleEntity']:
        """
        This field represents the entity that maintenance will be applied. Entity field takes two mandatory fields as id and type.
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of rule that will be defined in maintenance and can take either enabled or disabled for policy type rules. This field has to be disabled for integration type entity rules.
        """
        return pulumi.get(self, "state")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MaintenanceRuleEntity(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The id of the entity that maintenance will be applied.
        :param str type: This parameter defines when the maintenance will be active. It can take one of for-5-minutes, for-30-minutes, for-1-hour, indefinitely or schedule.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the entity that maintenance will be applied.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        This parameter defines when the maintenance will be active. It can take one of for-5-minutes, for-30-minutes, for-1-hour, indefinitely or schedule.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MaintenanceTime(dict):
    def __init__(__self__, *,
                 type: str,
                 end_date: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str type: This parameter defines when the maintenance will be active. It can take one of for-5-minutes, for-30-minutes, for-1-hour, indefinitely or schedule.
        :param str end_date: This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        :param str start_date: This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        pulumi.set(__self__, "type", type)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This parameter defines when the maintenance will be active. It can take one of for-5-minutes, for-30-minutes, for-1-hour, indefinitely or schedule.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        return pulumi.get(self, "start_date")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyAutoCloseAction(dict):
    def __init__(__self__, *,
                 durations: Sequence['outputs.NotificationPolicyAutoCloseActionDuration']):
        """
        :param Sequence['NotificationPolicyAutoCloseActionDurationArgs'] durations: Duration of this action. If `delay_option` = "for-duration" this has to be set. This is a block, structure is documented below.
        """
        pulumi.set(__self__, "durations", durations)

    @property
    @pulumi.getter
    def durations(self) -> Sequence['outputs.NotificationPolicyAutoCloseActionDuration']:
        """
        Duration of this action. If `delay_option` = "for-duration" this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyAutoCloseActionDuration(dict):
    def __init__(__self__, *,
                 time_amount: int,
                 time_unit: Optional[str] = None):
        """
        :param int time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param str time_unit: Valid time units are: "minutes", "hours", "days". Default: minutes
        """
        pulumi.set(__self__, "time_amount", time_amount)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> int:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        Valid time units are: "minutes", "hours", "days". Default: minutes
        """
        return pulumi.get(self, "time_unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyAutoRestartAction(dict):
    def __init__(__self__, *,
                 durations: Sequence['outputs.NotificationPolicyAutoRestartActionDuration'],
                 max_repeat_count: int):
        """
        :param Sequence['NotificationPolicyAutoRestartActionDurationArgs'] durations: Duration of this action. If `delay_option` = "for-duration" this has to be set. This is a block, structure is documented below.
        :param int max_repeat_count: How many times to repeat. This is a integer attribute.
        """
        pulumi.set(__self__, "durations", durations)
        pulumi.set(__self__, "max_repeat_count", max_repeat_count)

    @property
    @pulumi.getter
    def durations(self) -> Sequence['outputs.NotificationPolicyAutoRestartActionDuration']:
        """
        Duration of this action. If `delay_option` = "for-duration" this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    @property
    @pulumi.getter(name="maxRepeatCount")
    def max_repeat_count(self) -> int:
        """
        How many times to repeat. This is a integer attribute.
        """
        return pulumi.get(self, "max_repeat_count")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyAutoRestartActionDuration(dict):
    def __init__(__self__, *,
                 time_amount: int,
                 time_unit: Optional[str] = None):
        """
        :param int time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param str time_unit: Valid time units are: "minutes", "hours", "days". Default: minutes
        """
        pulumi.set(__self__, "time_amount", time_amount)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> int:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        Valid time units are: "minutes", "hours", "days". Default: minutes
        """
        return pulumi.get(self, "time_unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyDeDuplicationAction(dict):
    def __init__(__self__, *,
                 count: int,
                 de_duplication_action_type: str,
                 durations: Optional[Sequence['outputs.NotificationPolicyDeDuplicationActionDuration']] = None):
        """
        :param int count: - Count
        :param str de_duplication_action_type: Deduplication type. Possible values are: "value-based", "frequency-based"
        :param Sequence['NotificationPolicyDeDuplicationActionDurationArgs'] durations: Duration of this action. If `delay_option` = "for-duration" this has to be set. This is a block, structure is documented below.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "de_duplication_action_type", de_duplication_action_type)
        if durations is not None:
            pulumi.set(__self__, "durations", durations)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        - Count
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="deDuplicationActionType")
    def de_duplication_action_type(self) -> str:
        """
        Deduplication type. Possible values are: "value-based", "frequency-based"
        """
        return pulumi.get(self, "de_duplication_action_type")

    @property
    @pulumi.getter
    def durations(self) -> Optional[Sequence['outputs.NotificationPolicyDeDuplicationActionDuration']]:
        """
        Duration of this action. If `delay_option` = "for-duration" this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyDeDuplicationActionDuration(dict):
    def __init__(__self__, *,
                 time_amount: int,
                 time_unit: Optional[str] = None):
        """
        :param int time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param str time_unit: Valid time units are: "minutes", "hours", "days". Default: minutes
        """
        pulumi.set(__self__, "time_amount", time_amount)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> int:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        Valid time units are: "minutes", "hours", "days". Default: minutes
        """
        return pulumi.get(self, "time_unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyDelayAction(dict):
    def __init__(__self__, *,
                 delay_option: str,
                 durations: Optional[Sequence['outputs.NotificationPolicyDelayActionDuration']] = None,
                 until_hour: Optional[int] = None,
                 until_minute: Optional[int] = None):
        """
        :param str delay_option: Defines until what day to delay or for what duration. Possible values are: "for-duration", "next-time", "next-weekday", "next-monday", "next-tuesday", "next-wednesday", "next-thursday", "next-friday", "next-saturday", "next-sunday"
        :param Sequence['NotificationPolicyDelayActionDurationArgs'] durations: Duration of this action. If `delay_option` = "for-duration" this has to be set. This is a block, structure is documented below.
        :param int until_hour: Until what hour notifications will be delayed. If `delay_option` is set to antyhing else then "for-duration" this has to be set.
        :param int until_minute: Until what minute on `until_hour` notifications will be delayed. If `delay_option` is set to antyhing else then "for-duration" this has to be set.
        """
        pulumi.set(__self__, "delay_option", delay_option)
        if durations is not None:
            pulumi.set(__self__, "durations", durations)
        if until_hour is not None:
            pulumi.set(__self__, "until_hour", until_hour)
        if until_minute is not None:
            pulumi.set(__self__, "until_minute", until_minute)

    @property
    @pulumi.getter(name="delayOption")
    def delay_option(self) -> str:
        """
        Defines until what day to delay or for what duration. Possible values are: "for-duration", "next-time", "next-weekday", "next-monday", "next-tuesday", "next-wednesday", "next-thursday", "next-friday", "next-saturday", "next-sunday"
        """
        return pulumi.get(self, "delay_option")

    @property
    @pulumi.getter
    def durations(self) -> Optional[Sequence['outputs.NotificationPolicyDelayActionDuration']]:
        """
        Duration of this action. If `delay_option` = "for-duration" this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    @property
    @pulumi.getter(name="untilHour")
    def until_hour(self) -> Optional[int]:
        """
        Until what hour notifications will be delayed. If `delay_option` is set to antyhing else then "for-duration" this has to be set.
        """
        return pulumi.get(self, "until_hour")

    @property
    @pulumi.getter(name="untilMinute")
    def until_minute(self) -> Optional[int]:
        """
        Until what minute on `until_hour` notifications will be delayed. If `delay_option` is set to antyhing else then "for-duration" this has to be set.
        """
        return pulumi.get(self, "until_minute")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyDelayActionDuration(dict):
    def __init__(__self__, *,
                 time_amount: int,
                 time_unit: Optional[str] = None):
        """
        :param int time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param str time_unit: Valid time units are: "minutes", "hours", "days". Default: minutes
        """
        pulumi.set(__self__, "time_amount", time_amount)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> int:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        Valid time units are: "minutes", "hours", "days". Default: minutes
        """
        return pulumi.get(self, "time_unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.NotificationPolicyFilterCondition']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['NotificationPolicyFilterConditionArgs'] conditions: Conditions applied to filter. This is a block, structure is documented below.
        :param str type: Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: "time-of-day", "weekday-and-time-of-day"
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.NotificationPolicyFilterCondition']]:
        """
        Conditions applied to filter. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: "time-of-day", "weekday-and-time-of-day"
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyFilterCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param str field: Specifies which alert field will be used in condition. Possible values are "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        :param str operation: It is the operation that will be executed for the given field and key. Possible operations are "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace".
        :param str expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param str key: If `field` is set as extra-properties, key could be used for key-value pair
        :param bool not_: Indicates behaviour of the given operation. Default: false
        :param int order: Order of the condition in conditions list
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Specifies which alert field will be used in condition. Possible values are "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        It is the operation that will be executed for the given field and key. Possible operations are "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace".
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        If `field` is set as extra-properties, key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default: false
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyTimeRestriction(dict):
    def __init__(__self__, *,
                 type: str,
                 restrictions: Optional[Sequence['outputs.NotificationPolicyTimeRestrictionRestriction']] = None):
        """
        :param str type: Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: "time-of-day", "weekday-and-time-of-day"
        :param Sequence['NotificationPolicyTimeRestrictionRestrictionArgs'] restrictions: List of days and hours definitions for field type = "weekday-and-time-of-day". This is a block, structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: "time-of-day", "weekday-and-time-of-day"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.NotificationPolicyTimeRestrictionRestriction']]:
        """
        List of days and hours definitions for field type = "weekday-and-time-of-day". This is a block, structure is documented below.
        """
        return pulumi.get(self, "restrictions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationPolicyTimeRestrictionRestriction(dict):
    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        """
        :param str end_day: Ending day of restriction (eg. "wednesday)
        :param int end_hour: Ending hour of restriction.
        :param int end_min: Ending minute of restriction on defined `end_hour`
        :param str start_day: Starting day of restriction (eg. "monday")
        :param int start_hour: Starting hour of restriction.
        :param int start_min: Staring minute of restriction on defined `start_hour`
        """
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        """
        Ending day of restriction (eg. "wednesday)
        """
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Ending hour of restriction.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Ending minute of restriction on defined `end_hour`
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        """
        Starting day of restriction (eg. "monday")
        """
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Starting hour of restriction.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Staring minute of restriction on defined `start_hour`
        """
        return pulumi.get(self, "start_min")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationRuleCriteria(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.NotificationRuleCriteriaCondition']] = None):
        """
        :param str type: Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        :param Sequence['NotificationRuleCriteriaConditionArgs'] conditions: Defines the fields and values when the condition applies
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.NotificationRuleCriteriaCondition']]:
        """
        Defines the fields and values when the condition applies
        """
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationRuleCriteriaCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param str field: Possible values: "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        :param str operation: Possible values: "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace
        :param str key: If 'field' is set as 'extra-properties', key could be used for key-value pair
        :param bool not_: Indicates behaviour of the given operation. Default value is false
        :param int order: Order of the condition in conditions list
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Possible values: "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Possible values: "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        If 'field' is set as 'extra-properties', key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default value is false
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationRuleRepeat(dict):
    def __init__(__self__, *,
                 loop_after: int,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Defined if this step is enabled. Default: true
        """
        pulumi.set(__self__, "loop_after", loop_after)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="loopAfter")
    def loop_after(self) -> int:
        return pulumi.get(self, "loop_after")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defined if this step is enabled. Default: true
        """
        return pulumi.get(self, "enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationRuleSchedule(dict):
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None):
        """
        :param str type: Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        :param str name: Name of the notification policy
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the notification policy
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationRuleStep(dict):
    def __init__(__self__, *,
                 contacts: Sequence['outputs.NotificationRuleStepContact'],
                 enabled: Optional[bool] = None,
                 send_after: Optional[int] = None):
        """
        :param Sequence['NotificationRuleStepContactArgs'] contacts: Defines the contact that notification will be sent to. This is a block, structure is documented below.
        :param bool enabled: Defined if this step is enabled. Default: true
        :param int send_after: Minute time period notification will be sent after.
        """
        pulumi.set(__self__, "contacts", contacts)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if send_after is not None:
            pulumi.set(__self__, "send_after", send_after)

    @property
    @pulumi.getter
    def contacts(self) -> Sequence['outputs.NotificationRuleStepContact']:
        """
        Defines the contact that notification will be sent to. This is a block, structure is documented below.
        """
        return pulumi.get(self, "contacts")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defined if this step is enabled. Default: true
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="sendAfter")
    def send_after(self) -> Optional[int]:
        """
        Minute time period notification will be sent after.
        """
        return pulumi.get(self, "send_after")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationRuleStepContact(dict):
    def __init__(__self__, *,
                 method: str,
                 to: str):
        """
        :param str method: Contact method. Possible values: "email", "sms", "voice", "mobile"
        :param str to: Address of a given method (eg. phone number for sms/voice or email address for email)
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Contact method. Possible values: "email", "sms", "voice", "mobile"
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def to(self) -> str:
        """
        Address of a given method (eg. phone number for sms/voice or email address for email)
        """
        return pulumi.get(self, "to")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationRuleTimeRestriction(dict):
    def __init__(__self__, *,
                 type: str,
                 restrictions: Optional[Sequence['outputs.NotificationRuleTimeRestrictionRestriction']] = None):
        """
        :param str type: Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Kind of matching filter  "match-all", "match-any-condition", "match-all-conditions"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.NotificationRuleTimeRestrictionRestriction']]:
        return pulumi.get(self, "restrictions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NotificationRuleTimeRestrictionRestriction(dict):
    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        return pulumi.get(self, "start_min")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleRotationParticipant(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str type: The responder type.
        :param str id: The id of the responder.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleRotationTimeRestriction(dict):
    def __init__(__self__, *,
                 type: str,
                 restrictions: Optional[Sequence['outputs.ScheduleRotationTimeRestrictionRestriction']] = None):
        """
        :param str type: This parameter should be set to `time-of-day` or `weekday-and-time-of-day`.
        :param Sequence['ScheduleRotationTimeRestrictionRestrictionArgs'] restrictions: It is a restriction object which is described below. This can be used only if time restriction type is `weekday-and-time-of-day`.
        """
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This parameter should be set to `time-of-day` or `weekday-and-time-of-day`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.ScheduleRotationTimeRestrictionRestriction']]:
        """
        It is a restriction object which is described below. This can be used only if time restriction type is `weekday-and-time-of-day`.
        """
        return pulumi.get(self, "restrictions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleRotationTimeRestrictionRestriction(dict):
    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        """
        :param str end_day: Value of the day that frame will end.
        :param int end_hour: Value of the hour that frame will end.
        :param int end_min: Value of the minute that frame will end. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        :param str start_day: Value of the day that frame will start.
        :param int start_hour: Value of the hour that frame will start
        :param int start_min: Value of the minute that frame will start. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        """
        Value of the day that frame will end.
        """
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Value of the hour that frame will end.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Value of the minute that frame will end. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        """
        Value of the day that frame will start.
        """
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Value of the hour that frame will start
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Value of the minute that frame will start. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        return pulumi.get(self, "start_min")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceIncidentRuleIncidentRule(dict):
    def __init__(__self__, *,
                 incident_properties: Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentProperty'],
                 condition_match_type: Optional[str] = None,
                 conditions: Optional[Sequence['outputs.ServiceIncidentRuleIncidentRuleCondition']] = None):
        """
        :param Sequence['ServiceIncidentRuleIncidentRuleIncidentPropertyArgs'] incident_properties: Properties for incident rule. This is a block, structure is documented below.
        :param str condition_match_type: A Condition type, supported types are: "match-all", "match-any-condition", "match-all-conditions". Default: "match-all"
        :param Sequence['ServiceIncidentRuleIncidentRuleConditionArgs'] conditions: Conditions applied to incident. This is a block, structure is documented below.
        """
        pulumi.set(__self__, "incident_properties", incident_properties)
        if condition_match_type is not None:
            pulumi.set(__self__, "condition_match_type", condition_match_type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter(name="incidentProperties")
    def incident_properties(self) -> Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentProperty']:
        """
        Properties for incident rule. This is a block, structure is documented below.
        """
        return pulumi.get(self, "incident_properties")

    @property
    @pulumi.getter(name="conditionMatchType")
    def condition_match_type(self) -> Optional[str]:
        """
        A Condition type, supported types are: "match-all", "match-any-condition", "match-all-conditions". Default: "match-all"
        """
        return pulumi.get(self, "condition_match_type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ServiceIncidentRuleIncidentRuleCondition']]:
        """
        Conditions applied to incident. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceIncidentRuleIncidentRuleCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None):
        """
        :param str field: Specifies which alert field will be used in condition. Possible values are "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        :param str operation: It is the operation that will be executed for the given field and key. Possible operations are "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace".
        :param str expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param bool not_: Indicates behaviour of the given operation. Default: false
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Specifies which alert field will be used in condition. Possible values are "message", "alias", "description", "source", "entity", "tags", "actions", "details", "extra-properties", "recipients", "teams", "priority"
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        It is the operation that will be executed for the given field and key. Possible operations are "matches", "contains", "starts-with", "ends-with", "equals", "contains-key", "contains-value", "greater-than", "less-than", "is-empty", "equals-ignore-whitespace".
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default: false
        """
        return pulumi.get(self, "not_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceIncidentRuleIncidentRuleIncidentProperty(dict):
    def __init__(__self__, *,
                 message: str,
                 priority: str,
                 stakeholder_properties: Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty'],
                 description: Optional[str] = None,
                 details: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param str message: Message that is to be passed to audience that is generally used to provide a content information about the alert.
        :param str priority: Priority level of the alert. Possible values are P1, P2, P3, P4 and P5
        :param Sequence['ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderPropertyArgs'] stakeholder_properties: DEtails about stakeholders for this rule. This is a block, structure is documented below.
        :param str description: Description that is generally used to provide a detailed information about the alert.
        :param Sequence[str] details: Map of key-value pairs to use as custom properties of the alert.
        :param Sequence[str] tags: Tags of the alert.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "stakeholder_properties", stakeholder_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message that is to be passed to audience that is generally used to provide a content information about the alert.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def priority(self) -> str:
        """
        Priority level of the alert. Possible values are P1, P2, P3, P4 and P5
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="stakeholderProperties")
    def stakeholder_properties(self) -> Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty']:
        """
        DEtails about stakeholders for this rule. This is a block, structure is documented below.
        """
        return pulumi.get(self, "stakeholder_properties")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description that is generally used to provide a detailed information about the alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence[str]]:
        """
        Map of key-value pairs to use as custom properties of the alert.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags of the alert.
        """
        return pulumi.get(self, "tags")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty(dict):
    def __init__(__self__, *,
                 message: str,
                 description: Optional[str] = None,
                 enable: Optional[bool] = None):
        """
        :param str message: Message that is to be passed to audience that is generally used to provide a content information about the alert.
        :param str description: Description that is generally used to provide a detailed information about the alert.
        :param bool enable: Option to enable stakeholder notifications.Default value is true.
        """
        pulumi.set(__self__, "message", message)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message that is to be passed to audience that is generally used to provide a content information about the alert.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description that is generally used to provide a detailed information about the alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Option to enable stakeholder notifications.Default value is true.
        """
        return pulumi.get(self, "enable")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TeamMember(dict):
    def __init__(__self__, *,
                 id: str,
                 role: Optional[str] = None):
        """
        :param str id: The UUID for the member to add to this Team.
        :param str role: The role for the user within the Team - can be either 'admin' or 'user', defaults to 'user' if not set.
        """
        pulumi.set(__self__, "id", id)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID for the member to add to this Team.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The role for the user within the Team - can be either 'admin' or 'user', defaults to 'user' if not set.
        """
        return pulumi.get(self, "role")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TeamRoutingRuleCriteria(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.TeamRoutingRuleCriteriaCondition']] = None):
        """
        :param str type: Type of the operation will be applied on conditions. Should be one of match-all, match-any-condition or match-all-conditions.
        :param Sequence['TeamRoutingRuleCriteriaConditionArgs'] conditions: List of conditions will be checked before applying team routing rule. This field declaration should be omitted if the criteria type is set to match-all.
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the operation will be applied on conditions. Should be one of match-all, match-any-condition or match-all-conditions.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.TeamRoutingRuleCriteriaCondition']]:
        """
        List of conditions will be checked before applying team routing rule. This field declaration should be omitted if the criteria type is set to match-all.
        """
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TeamRoutingRuleCriteriaCondition(dict):
    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param str field: Specifies which alert field will be used in condition. Possible values are message, alias, description, source, entity, tags, actions, extra-properties, recipients, teams or priority.
        :param str operation: It is the operation that will be executed for the given field and key. Possible operations are matches, contains, starts-with, ends-with, equals, contains-key, contains-value, greater-than, less-than, is-empty and equals-ignore-whitespace.
        :param str key: If field is set as extra-properties, key could be used for key-value pair.
        :param bool not_: Indicates behaviour of the given operation. Default value is false.
        :param int order: Order of the condition in conditions list.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operation", operation)
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Specifies which alert field will be used in condition. Possible values are message, alias, description, source, entity, tags, actions, extra-properties, recipients, teams or priority.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        It is the operation that will be executed for the given field and key. Possible operations are matches, contains, starts-with, ends-with, equals, contains-key, contains-value, greater-than, less-than, is-empty and equals-ignore-whitespace.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        If field is set as extra-properties, key could be used for key-value pair.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default value is false.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of the condition in conditions list.
        """
        return pulumi.get(self, "order")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TeamRoutingRuleNotify(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Team Routing Rule.
        :param str name: Name of the team routing rule
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Team Routing Rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the team routing rule
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TeamRoutingRuleTimeRestriction(dict):
    def __init__(__self__, *,
                 type: str,
                 restrictions: Optional[Sequence['outputs.TeamRoutingRuleTimeRestrictionRestriction']] = None):
        pulumi.set(__self__, "type", type)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.TeamRoutingRuleTimeRestrictionRestriction']]:
        return pulumi.get(self, "restrictions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TeamRoutingRuleTimeRestrictionRestriction(dict):
    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_min", end_min)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        return pulumi.get(self, "start_min")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserUserAddress(dict):
    def __init__(__self__, *,
                 city: str,
                 country: str,
                 line: str,
                 state: str,
                 zipcode: str):
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "line", line)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "zipcode", zipcode)

    @property
    @pulumi.getter
    def city(self) -> str:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> str:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def line(self) -> str:
        return pulumi.get(self, "line")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def zipcode(self) -> str:
        return pulumi.get(self, "zipcode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetEscalationRepeatResult(dict):
    def __init__(__self__, *,
                 close_alert_after_all: Optional[bool] = None,
                 count: Optional[int] = None,
                 reset_recipient_states: Optional[bool] = None,
                 wait_interval: Optional[int] = None):
        if close_alert_after_all is not None:
            pulumi.set(__self__, "close_alert_after_all", close_alert_after_all)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if reset_recipient_states is not None:
            pulumi.set(__self__, "reset_recipient_states", reset_recipient_states)
        if wait_interval is not None:
            pulumi.set(__self__, "wait_interval", wait_interval)

    @property
    @pulumi.getter(name="closeAlertAfterAll")
    def close_alert_after_all(self) -> Optional[bool]:
        return pulumi.get(self, "close_alert_after_all")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="resetRecipientStates")
    def reset_recipient_states(self) -> Optional[bool]:
        return pulumi.get(self, "reset_recipient_states")

    @property
    @pulumi.getter(name="waitInterval")
    def wait_interval(self) -> Optional[int]:
        return pulumi.get(self, "wait_interval")


@pulumi.output_type
class GetEscalationRuleResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 delay: int,
                 notify_type: str,
                 recipients: Sequence['outputs.GetEscalationRuleRecipientResult']):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "notify_type", notify_type)
        pulumi.set(__self__, "recipients", recipients)

    @property
    @pulumi.getter
    def condition(self) -> str:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def delay(self) -> int:
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> str:
        return pulumi.get(self, "notify_type")

    @property
    @pulumi.getter
    def recipients(self) -> Sequence['outputs.GetEscalationRuleRecipientResult']:
        return pulumi.get(self, "recipients")


@pulumi.output_type
class GetEscalationRuleRecipientResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Escalation.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Escalation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTeamMemberResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 role: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Team.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Team.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")


