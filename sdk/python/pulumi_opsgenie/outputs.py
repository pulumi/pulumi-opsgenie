# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AlertPolicyFilter',
    'AlertPolicyFilterCondition',
    'AlertPolicyResponder',
    'AlertPolicyTimeRestriction',
    'AlertPolicyTimeRestrictionRestriction',
    'AlertPolicyTimeRestrictionRestrictionList',
    'ApiIntegrationResponder',
    'EmailIntegrationResponder',
    'EscalationRepeat',
    'EscalationRule',
    'EscalationRuleRecipient',
    'IncidentTemplateStakeholderProperty',
    'IntegrationActionAcknowledge',
    'IntegrationActionAcknowledgeFilter',
    'IntegrationActionAcknowledgeFilterCondition',
    'IntegrationActionAddNote',
    'IntegrationActionAddNoteFilter',
    'IntegrationActionAddNoteFilterCondition',
    'IntegrationActionClose',
    'IntegrationActionCloseFilter',
    'IntegrationActionCloseFilterCondition',
    'IntegrationActionCreate',
    'IntegrationActionCreateFilter',
    'IntegrationActionCreateFilterCondition',
    'IntegrationActionCreateResponder',
    'IntegrationActionIgnore',
    'IntegrationActionIgnoreFilter',
    'IntegrationActionIgnoreFilterCondition',
    'MaintenanceRule',
    'MaintenanceRuleEntity',
    'MaintenanceTime',
    'NotificationPolicyAutoCloseAction',
    'NotificationPolicyAutoCloseActionDuration',
    'NotificationPolicyAutoRestartAction',
    'NotificationPolicyAutoRestartActionDuration',
    'NotificationPolicyDeDuplicationAction',
    'NotificationPolicyDeDuplicationActionDuration',
    'NotificationPolicyDelayAction',
    'NotificationPolicyDelayActionDuration',
    'NotificationPolicyFilter',
    'NotificationPolicyFilterCondition',
    'NotificationPolicyTimeRestriction',
    'NotificationPolicyTimeRestrictionRestriction',
    'NotificationPolicyTimeRestrictionRestrictionList',
    'NotificationRuleCriteria',
    'NotificationRuleCriteriaCondition',
    'NotificationRuleRepeat',
    'NotificationRuleSchedule',
    'NotificationRuleStep',
    'NotificationRuleStepContact',
    'NotificationRuleTimeRestriction',
    'NotificationRuleTimeRestrictionRestriction',
    'ScheduleRotationParticipant',
    'ScheduleRotationTimeRestriction',
    'ScheduleRotationTimeRestrictionRestriction',
    'ScheduleRotationTimeRestrictionRestrictionList',
    'ServiceIncidentRuleIncidentRule',
    'ServiceIncidentRuleIncidentRuleCondition',
    'ServiceIncidentRuleIncidentRuleIncidentProperty',
    'ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty',
    'TeamMember',
    'TeamRoutingRuleCriteria',
    'TeamRoutingRuleCriteriaCondition',
    'TeamRoutingRuleNotify',
    'TeamRoutingRuleTimeRestriction',
    'TeamRoutingRuleTimeRestrictionRestriction',
    'TeamRoutingRuleTimeRestrictionRestrictionList',
    'UserUserAddress',
    'GetEscalationRepeatResult',
    'GetEscalationRuleResult',
    'GetEscalationRuleRecipientResult',
    'GetTeamMemberResult',
]

@pulumi.output_type
class AlertPolicyFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.AlertPolicyFilterCondition']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['AlertPolicyFilterConditionArgs'] conditions: Conditions applied to filter. This is a block, structure is documented below.
        :param str type: A filter type, supported types are: `match-all`, `match-any-condition`, `match-all-conditions`. Default: `match-all`
        """
        AlertPolicyFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.AlertPolicyFilterCondition']] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditions is not None:
            _setter("conditions", conditions)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.AlertPolicyFilterCondition']]:
        """
        Conditions applied to filter. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        A filter type, supported types are: `match-all`, `match-any-condition`, `match-all-conditions`. Default: `match-all`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AlertPolicyFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPolicyFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPolicyFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPolicyFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param str field: Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `responders`, `teams`, `priority`
        :param str operation: It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        :param str expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param str key: If `field` is set as extra-properties, key could be used for key-value pair
        :param bool not_: Indicates behaviour of the given operation. Default: `false`
        :param int order: Order of the condition in conditions list
        """
        AlertPolicyFilterCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `responders`, `teams`, `priority`
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        If `field` is set as extra-properties, key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default: `false`
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class AlertPolicyResponder(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str,
                 name: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str id: ID of the responder
        :param str type: Type of responder. Acceptable values are: `user`, `team`, `escalation` or `schedule`
        :param str name: Name of the responder
        :param str username: Username of the responder
        """
        AlertPolicyResponder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
            name=name,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             type: str,
             name: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("type", type)
        if name is not None:
            _setter("name", name)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of responder. Acceptable values are: `user`, `team`, `escalation` or `schedule`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the responder
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of the responder
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class AlertPolicyTimeRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionList":
            suggest = "restriction_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPolicyTimeRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPolicyTimeRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPolicyTimeRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 restriction: Optional[Sequence['outputs.AlertPolicyTimeRestrictionRestriction']] = None,
                 restriction_list: Optional[Sequence['outputs.AlertPolicyTimeRestrictionRestrictionList']] = None):
        """
        :param str type: Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: `time-of-day`, `weekday-and-time-of-day`
        :param Sequence['AlertPolicyTimeRestrictionRestrictionArgs'] restriction: A definition of hourly definition applied daily, this has to be used with combination: type = `time-of-day`. This is a block, structure is documented below.
        :param Sequence['AlertPolicyTimeRestrictionRestrictionListArgs'] restriction_list: List of days and hours definitions for field type = `weekday-and-time-of-day`. This is a block, structure is documented below.
        """
        AlertPolicyTimeRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            restriction=restriction,
            restriction_list=restriction_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             restriction: Optional[Sequence['outputs.AlertPolicyTimeRestrictionRestriction']] = None,
             restriction_list: Optional[Sequence['outputs.AlertPolicyTimeRestrictionRestrictionList']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if restriction is not None:
            _setter("restriction", restriction)
        if restriction_list is not None:
            _setter("restriction_list", restriction_list)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: `time-of-day`, `weekday-and-time-of-day`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restriction(self) -> Optional[Sequence['outputs.AlertPolicyTimeRestrictionRestriction']]:
        """
        A definition of hourly definition applied daily, this has to be used with combination: type = `time-of-day`. This is a block, structure is documented below.
        """
        return pulumi.get(self, "restriction")

    @property
    @pulumi.getter(name="restrictionList")
    def restriction_list(self) -> Optional[Sequence['outputs.AlertPolicyTimeRestrictionRestrictionList']]:
        """
        List of days and hours definitions for field type = `weekday-and-time-of-day`. This is a block, structure is documented below.
        """
        return pulumi.get(self, "restriction_list")


@pulumi.output_type
class AlertPolicyTimeRestrictionRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPolicyTimeRestrictionRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPolicyTimeRestrictionRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPolicyTimeRestrictionRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_hour: int,
                 end_min: int,
                 start_hour: int,
                 start_min: int):
        """
        :param int end_hour: Ending hour of restriction.
        :param int end_min: Ending minute of restriction on defined `end_hour`
        :param int start_hour: Starting hour of restriction.
        :param int start_min: Staring minute of restriction on defined `start_hour`
        """
        AlertPolicyTimeRestrictionRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_hour=end_hour,
            end_min=end_min,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_hour: int,
             end_min: int,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Ending hour of restriction.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Ending minute of restriction on defined `end_hour`
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Starting hour of restriction.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Staring minute of restriction on defined `start_hour`
        """
        return pulumi.get(self, "start_min")


@pulumi.output_type
class AlertPolicyTimeRestrictionRestrictionList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDay":
            suggest = "end_day"
        elif key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startDay":
            suggest = "start_day"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPolicyTimeRestrictionRestrictionList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPolicyTimeRestrictionRestrictionList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPolicyTimeRestrictionRestrictionList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        """
        :param str end_day: Ending day of restriction (eg. `wednesday`)
        :param int end_hour: Ending hour of restriction on defined `end_day`
        :param int end_min: Ending minute of restriction on defined `end_hour`
        :param str start_day: Starting day of restriction (eg. `monday`)
        :param int start_hour: Starting hour of restriction on defined `start_day`
        :param int start_min: Staring minute of restriction on defined `start_hour`
        """
        AlertPolicyTimeRestrictionRestrictionList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_day=end_day,
            end_hour=end_hour,
            end_min=end_min,
            start_day=start_day,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_day: str,
             end_hour: int,
             end_min: int,
             start_day: str,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_day", end_day)
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_day", start_day)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        """
        Ending day of restriction (eg. `wednesday`)
        """
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Ending hour of restriction on defined `end_day`
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Ending minute of restriction on defined `end_hour`
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        """
        Starting day of restriction (eg. `monday`)
        """
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Starting hour of restriction on defined `start_day`
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Staring minute of restriction on defined `start_hour`
        """
        return pulumi.get(self, "start_min")


@pulumi.output_type
class ApiIntegrationResponder(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The id of the responder.
        :param str type: The responder type.
        """
        ApiIntegrationResponder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EmailIntegrationResponder(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The id of the responder.
        :param str type: The responder type.
        """
        EmailIntegrationResponder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EscalationRepeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "closeAlertAfterAll":
            suggest = "close_alert_after_all"
        elif key == "resetRecipientStates":
            suggest = "reset_recipient_states"
        elif key == "waitInterval":
            suggest = "wait_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationRepeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationRepeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationRepeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 close_alert_after_all: Optional[bool] = None,
                 count: Optional[int] = None,
                 reset_recipient_states: Optional[bool] = None,
                 wait_interval: Optional[int] = None):
        EscalationRepeat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            close_alert_after_all=close_alert_after_all,
            count=count,
            reset_recipient_states=reset_recipient_states,
            wait_interval=wait_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             close_alert_after_all: Optional[bool] = None,
             count: Optional[int] = None,
             reset_recipient_states: Optional[bool] = None,
             wait_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if close_alert_after_all is not None:
            _setter("close_alert_after_all", close_alert_after_all)
        if count is not None:
            _setter("count", count)
        if reset_recipient_states is not None:
            _setter("reset_recipient_states", reset_recipient_states)
        if wait_interval is not None:
            _setter("wait_interval", wait_interval)

    @property
    @pulumi.getter(name="closeAlertAfterAll")
    def close_alert_after_all(self) -> Optional[bool]:
        return pulumi.get(self, "close_alert_after_all")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="resetRecipientStates")
    def reset_recipient_states(self) -> Optional[bool]:
        return pulumi.get(self, "reset_recipient_states")

    @property
    @pulumi.getter(name="waitInterval")
    def wait_interval(self) -> Optional[int]:
        return pulumi.get(self, "wait_interval")


@pulumi.output_type
class EscalationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyType":
            suggest = "notify_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: str,
                 delay: int,
                 notify_type: str,
                 recipients: Sequence['outputs.EscalationRuleRecipient']):
        """
        :param str condition: The condition for notifying the recipient of escalation rule that is based on the alert state. Possible values are: `if-not-acked` and `if-not-closed`. Default: `if-not-acked`
        :param int delay: Time delay of the escalation rule, in minutes.
        :param str notify_type: Recipient calculation logic for schedules. Possible values are:
        :param Sequence['EscalationRuleRecipientArgs'] recipients: Object of schedule, team, or users which will be notified in escalation. The possible values for participants are: `user`, `schedule`, `team`.
        """
        EscalationRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            delay=delay,
            notify_type=notify_type,
            recipients=recipients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             delay: int,
             notify_type: str,
             recipients: Sequence['outputs.EscalationRuleRecipient'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("condition", condition)
        _setter("delay", delay)
        _setter("notify_type", notify_type)
        _setter("recipients", recipients)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        The condition for notifying the recipient of escalation rule that is based on the alert state. Possible values are: `if-not-acked` and `if-not-closed`. Default: `if-not-acked`
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def delay(self) -> int:
        """
        Time delay of the escalation rule, in minutes.
        """
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> str:
        """
        Recipient calculation logic for schedules. Possible values are:
        """
        return pulumi.get(self, "notify_type")

    @property
    @pulumi.getter
    def recipients(self) -> Sequence['outputs.EscalationRuleRecipient']:
        """
        Object of schedule, team, or users which will be notified in escalation. The possible values for participants are: `user`, `schedule`, `team`.
        """
        return pulumi.get(self, "recipients")


@pulumi.output_type
class EscalationRuleRecipient(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Escalation.
        """
        EscalationRuleRecipient._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Escalation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class IncidentTemplateStakeholderProperty(dict):
    def __init__(__self__, *,
                 message: str,
                 description: Optional[str] = None,
                 enable: Optional[bool] = None):
        """
        :param str message: Message that is to be passed to audience that is generally used to provide a content information about the alert.
        :param str description: Description that is generally used to provide a detailed information about the alert. This field must not be longer than 15000 characters.
        :param bool enable: Option to enable stakeholder notifications.Default value is true.
        """
        IncidentTemplateStakeholderProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            description=description,
            enable=enable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: str,
             description: Optional[str] = None,
             enable: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("message", message)
        if description is not None:
            _setter("description", description)
        if enable is not None:
            _setter("enable", enable)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message that is to be passed to audience that is generally used to provide a content information about the alert.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description that is generally used to provide a detailed information about the alert. This field must not be longer than 15000 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Option to enable stakeholder notifications.Default value is true.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class IntegrationActionAcknowledge(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 filters: Optional[Sequence['outputs.IntegrationActionAcknowledgeFilter']] = None,
                 note: Optional[str] = None,
                 order: Optional[int] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param str alias: An identifier that is used for alert deduplication. Default: `{{alias}}`.
        :param Sequence['IntegrationActionAcknowledgeFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param str note: Additional alert action note.
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        :param str user: Owner of the execution for integration action.
        """
        IntegrationActionAcknowledge._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            alias=alias,
            filters=filters,
            note=note,
            order=order,
            type=type,
            user=user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             alias: Optional[str] = None,
             filters: Optional[Sequence['outputs.IntegrationActionAcknowledgeFilter']] = None,
             note: Optional[str] = None,
             order: Optional[int] = None,
             type: Optional[str] = None,
             user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if alias is not None:
            _setter("alias", alias)
        if filters is not None:
            _setter("filters", filters)
        if note is not None:
            _setter("note", note)
        if order is not None:
            _setter("order", order)
        if type is not None:
            _setter("type", type)
        if user is not None:
            _setter("user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An identifier that is used for alert deduplication. Default: `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionAcknowledgeFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Additional alert action note.
        """
        return pulumi.get(self, "note")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class IntegrationActionAcknowledgeFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionAcknowledgeFilterCondition']] = None):
        """
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        """
        IntegrationActionAcknowledgeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            conditions=conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             conditions: Optional[Sequence['outputs.IntegrationActionAcknowledgeFilterCondition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if conditions is not None:
            _setter("conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionAcknowledgeFilterCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class IntegrationActionAcknowledgeFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationActionAcknowledgeFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationActionAcknowledgeFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationActionAcknowledgeFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        IntegrationActionAcknowledgeFilterCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class IntegrationActionAddNote(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 filters: Optional[Sequence['outputs.IntegrationActionAddNoteFilter']] = None,
                 note: Optional[str] = None,
                 order: Optional[int] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param str alias: An identifier that is used for alert deduplication. Default: `{{alias}}`.
        :param Sequence['IntegrationActionAddNoteFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param str note: Additional alert action note.
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        :param str user: Owner of the execution for integration action.
        """
        IntegrationActionAddNote._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            alias=alias,
            filters=filters,
            note=note,
            order=order,
            type=type,
            user=user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             alias: Optional[str] = None,
             filters: Optional[Sequence['outputs.IntegrationActionAddNoteFilter']] = None,
             note: Optional[str] = None,
             order: Optional[int] = None,
             type: Optional[str] = None,
             user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if alias is not None:
            _setter("alias", alias)
        if filters is not None:
            _setter("filters", filters)
        if note is not None:
            _setter("note", note)
        if order is not None:
            _setter("order", order)
        if type is not None:
            _setter("type", type)
        if user is not None:
            _setter("user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An identifier that is used for alert deduplication. Default: `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionAddNoteFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Additional alert action note.
        """
        return pulumi.get(self, "note")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class IntegrationActionAddNoteFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionAddNoteFilterCondition']] = None):
        """
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        """
        IntegrationActionAddNoteFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            conditions=conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             conditions: Optional[Sequence['outputs.IntegrationActionAddNoteFilterCondition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if conditions is not None:
            _setter("conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionAddNoteFilterCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class IntegrationActionAddNoteFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationActionAddNoteFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationActionAddNoteFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationActionAddNoteFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        IntegrationActionAddNoteFilterCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class IntegrationActionClose(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 filters: Optional[Sequence['outputs.IntegrationActionCloseFilter']] = None,
                 note: Optional[str] = None,
                 order: Optional[int] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param str alias: An identifier that is used for alert deduplication. Default: `{{alias}}`.
        :param Sequence['IntegrationActionCloseFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param str note: Additional alert action note.
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        :param str user: Owner of the execution for integration action.
        """
        IntegrationActionClose._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            alias=alias,
            filters=filters,
            note=note,
            order=order,
            type=type,
            user=user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             alias: Optional[str] = None,
             filters: Optional[Sequence['outputs.IntegrationActionCloseFilter']] = None,
             note: Optional[str] = None,
             order: Optional[int] = None,
             type: Optional[str] = None,
             user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if alias is not None:
            _setter("alias", alias)
        if filters is not None:
            _setter("filters", filters)
        if note is not None:
            _setter("note", note)
        if order is not None:
            _setter("order", order)
        if type is not None:
            _setter("type", type)
        if user is not None:
            _setter("user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An identifier that is used for alert deduplication. Default: `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionCloseFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Additional alert action note.
        """
        return pulumi.get(self, "note")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class IntegrationActionCloseFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionCloseFilterCondition']] = None):
        """
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        """
        IntegrationActionCloseFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            conditions=conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             conditions: Optional[Sequence['outputs.IntegrationActionCloseFilterCondition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if conditions is not None:
            _setter("conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionCloseFilterCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class IntegrationActionCloseFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationActionCloseFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationActionCloseFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationActionCloseFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        IntegrationActionCloseFilterCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class IntegrationActionCreate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertActions":
            suggest = "alert_actions"
        elif key == "appendAttachments":
            suggest = "append_attachments"
        elif key == "customPriority":
            suggest = "custom_priority"
        elif key == "extraProperties":
            suggest = "extra_properties"
        elif key == "ignoreAlertActionsFromPayload":
            suggest = "ignore_alert_actions_from_payload"
        elif key == "ignoreExtraPropertiesFromPayload":
            suggest = "ignore_extra_properties_from_payload"
        elif key == "ignoreRespondersFromPayload":
            suggest = "ignore_responders_from_payload"
        elif key == "ignoreTagsFromPayload":
            suggest = "ignore_tags_from_payload"
        elif key == "ignoreTeamsFromPayload":
            suggest = "ignore_teams_from_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationActionCreate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationActionCreate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationActionCreate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alert_actions: Optional[Sequence[str]] = None,
                 alias: Optional[str] = None,
                 append_attachments: Optional[bool] = None,
                 custom_priority: Optional[str] = None,
                 description: Optional[str] = None,
                 entity: Optional[str] = None,
                 extra_properties: Optional[Mapping[str, str]] = None,
                 filters: Optional[Sequence['outputs.IntegrationActionCreateFilter']] = None,
                 ignore_alert_actions_from_payload: Optional[bool] = None,
                 ignore_extra_properties_from_payload: Optional[bool] = None,
                 ignore_responders_from_payload: Optional[bool] = None,
                 ignore_tags_from_payload: Optional[bool] = None,
                 ignore_teams_from_payload: Optional[bool] = None,
                 message: Optional[str] = None,
                 note: Optional[str] = None,
                 order: Optional[int] = None,
                 priority: Optional[str] = None,
                 responders: Optional[Sequence['outputs.IntegrationActionCreateResponder']] = None,
                 source: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param str alias: An identifier that is used for alert deduplication. Default: `{{alias}}`.
        :param str custom_priority: Custom alert priority. e.g. ``{{message.substring(0,2)}}``
        :param str description: Detailed description of the alert, anything that may not have fit in the `message` field.
        :param str entity: The entity the alert is related to.
        :param Mapping[str, str] extra_properties: Set of user defined properties specified as a map.
        :param Sequence['IntegrationActionCreateFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param bool ignore_responders_from_payload: If enabled, the integration will ignore responders sent in request payloads.
        :param bool ignore_teams_from_payload: If enabled, the integration will ignore teams sent in request payloads.
        :param str message: Alert text limited to 130 characters.
        :param str note: Additional alert action note.
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param str priority: Alert priority.
        :param Sequence['IntegrationActionCreateResponderArgs'] responders: User, schedule, teams or escalation names to calculate which users will receive notifications of the alert.
        :param str source: User defined field to specify source of action.
        :param Sequence[str] tags: Comma separated list of labels to be attached to the alert.
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        :param str user: Owner of the execution for integration action.
        """
        IntegrationActionCreate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            alert_actions=alert_actions,
            alias=alias,
            append_attachments=append_attachments,
            custom_priority=custom_priority,
            description=description,
            entity=entity,
            extra_properties=extra_properties,
            filters=filters,
            ignore_alert_actions_from_payload=ignore_alert_actions_from_payload,
            ignore_extra_properties_from_payload=ignore_extra_properties_from_payload,
            ignore_responders_from_payload=ignore_responders_from_payload,
            ignore_tags_from_payload=ignore_tags_from_payload,
            ignore_teams_from_payload=ignore_teams_from_payload,
            message=message,
            note=note,
            order=order,
            priority=priority,
            responders=responders,
            source=source,
            tags=tags,
            type=type,
            user=user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             alert_actions: Optional[Sequence[str]] = None,
             alias: Optional[str] = None,
             append_attachments: Optional[bool] = None,
             custom_priority: Optional[str] = None,
             description: Optional[str] = None,
             entity: Optional[str] = None,
             extra_properties: Optional[Mapping[str, str]] = None,
             filters: Optional[Sequence['outputs.IntegrationActionCreateFilter']] = None,
             ignore_alert_actions_from_payload: Optional[bool] = None,
             ignore_extra_properties_from_payload: Optional[bool] = None,
             ignore_responders_from_payload: Optional[bool] = None,
             ignore_tags_from_payload: Optional[bool] = None,
             ignore_teams_from_payload: Optional[bool] = None,
             message: Optional[str] = None,
             note: Optional[str] = None,
             order: Optional[int] = None,
             priority: Optional[str] = None,
             responders: Optional[Sequence['outputs.IntegrationActionCreateResponder']] = None,
             source: Optional[str] = None,
             tags: Optional[Sequence[str]] = None,
             type: Optional[str] = None,
             user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if alert_actions is not None:
            _setter("alert_actions", alert_actions)
        if alias is not None:
            _setter("alias", alias)
        if append_attachments is not None:
            _setter("append_attachments", append_attachments)
        if custom_priority is not None:
            _setter("custom_priority", custom_priority)
        if description is not None:
            _setter("description", description)
        if entity is not None:
            _setter("entity", entity)
        if extra_properties is not None:
            _setter("extra_properties", extra_properties)
        if filters is not None:
            _setter("filters", filters)
        if ignore_alert_actions_from_payload is not None:
            _setter("ignore_alert_actions_from_payload", ignore_alert_actions_from_payload)
        if ignore_extra_properties_from_payload is not None:
            _setter("ignore_extra_properties_from_payload", ignore_extra_properties_from_payload)
        if ignore_responders_from_payload is not None:
            _setter("ignore_responders_from_payload", ignore_responders_from_payload)
        if ignore_tags_from_payload is not None:
            _setter("ignore_tags_from_payload", ignore_tags_from_payload)
        if ignore_teams_from_payload is not None:
            _setter("ignore_teams_from_payload", ignore_teams_from_payload)
        if message is not None:
            _setter("message", message)
        if note is not None:
            _setter("note", note)
        if order is not None:
            _setter("order", order)
        if priority is not None:
            _setter("priority", priority)
        if responders is not None:
            _setter("responders", responders)
        if source is not None:
            _setter("source", source)
        if tags is not None:
            _setter("tags", tags)
        if type is not None:
            _setter("type", type)
        if user is not None:
            _setter("user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="alertActions")
    def alert_actions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "alert_actions")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An identifier that is used for alert deduplication. Default: `{{alias}}`.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="appendAttachments")
    def append_attachments(self) -> Optional[bool]:
        return pulumi.get(self, "append_attachments")

    @property
    @pulumi.getter(name="customPriority")
    def custom_priority(self) -> Optional[str]:
        """
        Custom alert priority. e.g. ``{{message.substring(0,2)}}``
        """
        return pulumi.get(self, "custom_priority")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Detailed description of the alert, anything that may not have fit in the `message` field.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def entity(self) -> Optional[str]:
        """
        The entity the alert is related to.
        """
        return pulumi.get(self, "entity")

    @property
    @pulumi.getter(name="extraProperties")
    def extra_properties(self) -> Optional[Mapping[str, str]]:
        """
        Set of user defined properties specified as a map.
        """
        return pulumi.get(self, "extra_properties")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionCreateFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="ignoreAlertActionsFromPayload")
    def ignore_alert_actions_from_payload(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_alert_actions_from_payload")

    @property
    @pulumi.getter(name="ignoreExtraPropertiesFromPayload")
    def ignore_extra_properties_from_payload(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_extra_properties_from_payload")

    @property
    @pulumi.getter(name="ignoreRespondersFromPayload")
    def ignore_responders_from_payload(self) -> Optional[bool]:
        """
        If enabled, the integration will ignore responders sent in request payloads.
        """
        return pulumi.get(self, "ignore_responders_from_payload")

    @property
    @pulumi.getter(name="ignoreTagsFromPayload")
    def ignore_tags_from_payload(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_tags_from_payload")

    @property
    @pulumi.getter(name="ignoreTeamsFromPayload")
    def ignore_teams_from_payload(self) -> Optional[bool]:
        """
        If enabled, the integration will ignore teams sent in request payloads.
        """
        return pulumi.get(self, "ignore_teams_from_payload")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Alert text limited to 130 characters.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Additional alert action note.
        """
        return pulumi.get(self, "note")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        Alert priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def responders(self) -> Optional[Sequence['outputs.IntegrationActionCreateResponder']]:
        """
        User, schedule, teams or escalation names to calculate which users will receive notifications of the alert.
        """
        return pulumi.get(self, "responders")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        User defined field to specify source of action.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Comma separated list of labels to be attached to the alert.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Owner of the execution for integration action.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class IntegrationActionCreateFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionCreateFilterCondition']] = None):
        """
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        """
        IntegrationActionCreateFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            conditions=conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             conditions: Optional[Sequence['outputs.IntegrationActionCreateFilterCondition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if conditions is not None:
            _setter("conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionCreateFilterCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class IntegrationActionCreateFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationActionCreateFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationActionCreateFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationActionCreateFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        IntegrationActionCreateFilterCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class IntegrationActionCreateResponder(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The id of the responder.
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        """
        IntegrationActionCreateResponder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IntegrationActionIgnore(dict):
    def __init__(__self__, *,
                 name: str,
                 filters: Optional[Sequence['outputs.IntegrationActionIgnoreFilter']] = None,
                 order: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str name: Name of the integration action.
        :param Sequence['IntegrationActionIgnoreFilterArgs'] filters: Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
               * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
               * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
               * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        """
        IntegrationActionIgnore._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            filters=filters,
            order=order,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             filters: Optional[Sequence['outputs.IntegrationActionIgnoreFilter']] = None,
             order: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if filters is not None:
            _setter("filters", filters)
        if order is not None:
            _setter("order", order)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the integration action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.IntegrationActionIgnoreFilter']]:
        """
        Used to specify rules for matching alerts and the filter type. Please note that depending on the integration type the field names in the filter conditions are:
        * For SNS integration: `actions`, `alias`, `entity`, `Message`, `recipients`, `responders`, `Subject`, `tags`, `teams`, `eventType`, `Timestamp`, `TopicArn`.
        * For API integration: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`, `eventType`.
        * For Email integration: `from_address`, `from_name`, `conversationSubject`, `subject`
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IntegrationActionIgnoreFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.IntegrationActionIgnoreFilterCondition']] = None):
        """
        :param str type: The responder type - can be `escalation`, `team` or `user`.
        """
        IntegrationActionIgnoreFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            conditions=conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             conditions: Optional[Sequence['outputs.IntegrationActionIgnoreFilterCondition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if conditions is not None:
            _setter("conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type - can be `escalation`, `team` or `user`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.IntegrationActionIgnoreFilterCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class IntegrationActionIgnoreFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationActionIgnoreFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationActionIgnoreFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationActionIgnoreFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param int order: Integer value that defines in which order the action will be performed. Default: `1`.
        """
        IntegrationActionIgnoreFilterCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Integer value that defines in which order the action will be performed. Default: `1`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class MaintenanceRule(dict):
    def __init__(__self__, *,
                 entities: Sequence['outputs.MaintenanceRuleEntity'],
                 state: Optional[str] = None):
        """
        :param Sequence['MaintenanceRuleEntityArgs'] entities: This field represents the entity that maintenance will be applied. Entity field takes two mandatory fields as id and type.
        :param str state: State of rule that will be defined in maintenance and can take either enabled or disabled for policy type rules. This field has to be disabled for integration type entity rules.
        """
        MaintenanceRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entities=entities,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entities: Sequence['outputs.MaintenanceRuleEntity'],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("entities", entities)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def entities(self) -> Sequence['outputs.MaintenanceRuleEntity']:
        """
        This field represents the entity that maintenance will be applied. Entity field takes two mandatory fields as id and type.
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of rule that will be defined in maintenance and can take either enabled or disabled for policy type rules. This field has to be disabled for integration type entity rules.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MaintenanceRuleEntity(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The id of the entity that maintenance will be applied.
        :param str type: The type of the entity that maintenance will be applied. It can be either integration or policy.
        """
        MaintenanceRuleEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the entity that maintenance will be applied.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the entity that maintenance will be applied. It can be either integration or policy.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MaintenanceTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 end_date: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str type: The type of the entity that maintenance will be applied. It can be either integration or policy.
        :param str end_date: This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        :param str start_date: This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        MaintenanceTime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            end_date=end_date,
            start_date=start_date,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             end_date: Optional[str] = None,
             start_date: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if end_date is not None:
            _setter("end_date", end_date)
        if start_date is not None:
            _setter("start_date", start_date)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the entity that maintenance will be applied. It can be either integration or policy.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        This parameter takes a date format as (yyyy-MM-dd'T'HH:mm:ssZ) (e.g. 2019-06-11T08:00:00+02:00).
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class NotificationPolicyAutoCloseAction(dict):
    def __init__(__self__, *,
                 durations: Sequence['outputs.NotificationPolicyAutoCloseActionDuration']):
        """
        :param Sequence['NotificationPolicyAutoCloseActionDurationArgs'] durations: Duration of this action. This is a block, structure is documented below.
        """
        NotificationPolicyAutoCloseAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            durations=durations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             durations: Sequence['outputs.NotificationPolicyAutoCloseActionDuration'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("durations", durations)

    @property
    @pulumi.getter
    def durations(self) -> Sequence['outputs.NotificationPolicyAutoCloseActionDuration']:
        """
        Duration of this action. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")


@pulumi.output_type
class NotificationPolicyAutoCloseActionDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeAmount":
            suggest = "time_amount"
        elif key == "timeUnit":
            suggest = "time_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyAutoCloseActionDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyAutoCloseActionDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyAutoCloseActionDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_amount: int,
                 time_unit: Optional[str] = None):
        """
        :param int time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param str time_unit: Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        NotificationPolicyAutoCloseActionDuration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_amount=time_amount,
            time_unit=time_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_amount: int,
             time_unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("time_amount", time_amount)
        if time_unit is not None:
            _setter("time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> int:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        return pulumi.get(self, "time_unit")


@pulumi.output_type
class NotificationPolicyAutoRestartAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRepeatCount":
            suggest = "max_repeat_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyAutoRestartAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyAutoRestartAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyAutoRestartAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 durations: Sequence['outputs.NotificationPolicyAutoRestartActionDuration'],
                 max_repeat_count: int):
        """
        :param Sequence['NotificationPolicyAutoRestartActionDurationArgs'] durations: Duration of this action. This is a block, structure is documented below.
        :param int max_repeat_count: How many times to repeat. This is a integer attribute.
        """
        NotificationPolicyAutoRestartAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            durations=durations,
            max_repeat_count=max_repeat_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             durations: Sequence['outputs.NotificationPolicyAutoRestartActionDuration'],
             max_repeat_count: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("durations", durations)
        _setter("max_repeat_count", max_repeat_count)

    @property
    @pulumi.getter
    def durations(self) -> Sequence['outputs.NotificationPolicyAutoRestartActionDuration']:
        """
        Duration of this action. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    @property
    @pulumi.getter(name="maxRepeatCount")
    def max_repeat_count(self) -> int:
        """
        How many times to repeat. This is a integer attribute.
        """
        return pulumi.get(self, "max_repeat_count")


@pulumi.output_type
class NotificationPolicyAutoRestartActionDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeAmount":
            suggest = "time_amount"
        elif key == "timeUnit":
            suggest = "time_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyAutoRestartActionDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyAutoRestartActionDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyAutoRestartActionDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_amount: int,
                 time_unit: Optional[str] = None):
        """
        :param int time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param str time_unit: Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        NotificationPolicyAutoRestartActionDuration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_amount=time_amount,
            time_unit=time_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_amount: int,
             time_unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("time_amount", time_amount)
        if time_unit is not None:
            _setter("time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> int:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        return pulumi.get(self, "time_unit")


@pulumi.output_type
class NotificationPolicyDeDuplicationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deDuplicationActionType":
            suggest = "de_duplication_action_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyDeDuplicationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyDeDuplicationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyDeDuplicationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 de_duplication_action_type: str,
                 durations: Optional[Sequence['outputs.NotificationPolicyDeDuplicationActionDuration']] = None):
        """
        :param int count: Count
        :param str de_duplication_action_type: Deduplication type. Possible values are: "value-based", "frequency-based"
        :param Sequence['NotificationPolicyDeDuplicationActionDurationArgs'] durations: Duration of this action (only required for "frequency-based" de-duplication action). This is a block, structure is documented below.
        """
        NotificationPolicyDeDuplicationAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            de_duplication_action_type=de_duplication_action_type,
            durations=durations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: int,
             de_duplication_action_type: str,
             durations: Optional[Sequence['outputs.NotificationPolicyDeDuplicationActionDuration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("count", count)
        _setter("de_duplication_action_type", de_duplication_action_type)
        if durations is not None:
            _setter("durations", durations)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        Count
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="deDuplicationActionType")
    def de_duplication_action_type(self) -> str:
        """
        Deduplication type. Possible values are: "value-based", "frequency-based"
        """
        return pulumi.get(self, "de_duplication_action_type")

    @property
    @pulumi.getter
    def durations(self) -> Optional[Sequence['outputs.NotificationPolicyDeDuplicationActionDuration']]:
        """
        Duration of this action (only required for "frequency-based" de-duplication action). This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")


@pulumi.output_type
class NotificationPolicyDeDuplicationActionDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeAmount":
            suggest = "time_amount"
        elif key == "timeUnit":
            suggest = "time_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyDeDuplicationActionDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyDeDuplicationActionDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyDeDuplicationActionDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_amount: int,
                 time_unit: Optional[str] = None):
        """
        :param int time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param str time_unit: Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        NotificationPolicyDeDuplicationActionDuration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_amount=time_amount,
            time_unit=time_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_amount: int,
             time_unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("time_amount", time_amount)
        if time_unit is not None:
            _setter("time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> int:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        return pulumi.get(self, "time_unit")


@pulumi.output_type
class NotificationPolicyDelayAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayOption":
            suggest = "delay_option"
        elif key == "untilHour":
            suggest = "until_hour"
        elif key == "untilMinute":
            suggest = "until_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyDelayAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyDelayAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyDelayAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_option: str,
                 durations: Optional[Sequence['outputs.NotificationPolicyDelayActionDuration']] = None,
                 until_hour: Optional[int] = None,
                 until_minute: Optional[int] = None):
        """
        :param str delay_option: Defines until what day to delay or for what duration. Possible values are: `for-duration`, `next-time`, `next-weekday`, `next-monday`, `next-tuesday`, `next-wednesday`, `next-thursday`, `next-friday`, `next-saturday`, `next-sunday`
        :param Sequence['NotificationPolicyDelayActionDurationArgs'] durations: Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        :param int until_hour: Until what hour notifications will be delayed. If `delay_option` is set to antyhing else then `for-duration` this has to be set.
        :param int until_minute: Until what minute on `until_hour` notifications will be delayed. If `delay_option` is set to antyhing else then `for-duration` this has to be set.
        """
        NotificationPolicyDelayAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delay_option=delay_option,
            durations=durations,
            until_hour=until_hour,
            until_minute=until_minute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delay_option: str,
             durations: Optional[Sequence['outputs.NotificationPolicyDelayActionDuration']] = None,
             until_hour: Optional[int] = None,
             until_minute: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("delay_option", delay_option)
        if durations is not None:
            _setter("durations", durations)
        if until_hour is not None:
            _setter("until_hour", until_hour)
        if until_minute is not None:
            _setter("until_minute", until_minute)

    @property
    @pulumi.getter(name="delayOption")
    def delay_option(self) -> str:
        """
        Defines until what day to delay or for what duration. Possible values are: `for-duration`, `next-time`, `next-weekday`, `next-monday`, `next-tuesday`, `next-wednesday`, `next-thursday`, `next-friday`, `next-saturday`, `next-sunday`
        """
        return pulumi.get(self, "delay_option")

    @property
    @pulumi.getter
    def durations(self) -> Optional[Sequence['outputs.NotificationPolicyDelayActionDuration']]:
        """
        Duration of this action. If `delay_option` = `for-duration` this has to be set. This is a block, structure is documented below.
        """
        return pulumi.get(self, "durations")

    @property
    @pulumi.getter(name="untilHour")
    def until_hour(self) -> Optional[int]:
        """
        Until what hour notifications will be delayed. If `delay_option` is set to antyhing else then `for-duration` this has to be set.
        """
        return pulumi.get(self, "until_hour")

    @property
    @pulumi.getter(name="untilMinute")
    def until_minute(self) -> Optional[int]:
        """
        Until what minute on `until_hour` notifications will be delayed. If `delay_option` is set to antyhing else then `for-duration` this has to be set.
        """
        return pulumi.get(self, "until_minute")


@pulumi.output_type
class NotificationPolicyDelayActionDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeAmount":
            suggest = "time_amount"
        elif key == "timeUnit":
            suggest = "time_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyDelayActionDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyDelayActionDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyDelayActionDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_amount: int,
                 time_unit: Optional[str] = None):
        """
        :param int time_amount: A amount of time in `time_units`. This is a integer attribute.
        :param str time_unit: Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        NotificationPolicyDelayActionDuration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_amount=time_amount,
            time_unit=time_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_amount: int,
             time_unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("time_amount", time_amount)
        if time_unit is not None:
            _setter("time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> int:
        """
        A amount of time in `time_units`. This is a integer attribute.
        """
        return pulumi.get(self, "time_amount")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        Valid time units are: `minutes`, `hours`, `days`. Default: `minutes`
        """
        return pulumi.get(self, "time_unit")


@pulumi.output_type
class NotificationPolicyFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.NotificationPolicyFilterCondition']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['NotificationPolicyFilterConditionArgs'] conditions: Conditions applied to filter. This is a block, structure is documented below.
        :param str type: A filter type, supported types are: `match-all`, `match-any-condition`, `match-all-conditions`. Default: `match-all`
        """
        NotificationPolicyFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.NotificationPolicyFilterCondition']] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditions is not None:
            _setter("conditions", conditions)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.NotificationPolicyFilterCondition']]:
        """
        Conditions applied to filter. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        A filter type, supported types are: `match-all`, `match-any-condition`, `match-all-conditions`. Default: `match-all`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NotificationPolicyFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param str field: Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `responders`, `teams`, `priority`
        :param str operation: It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        :param str expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param str key: If `field` is set as extra-properties, key could be used for key-value pair
        :param bool not_: Indicates behaviour of the given operation. Default: `false`
        :param int order: Order of the condition in conditions list
        """
        NotificationPolicyFilterCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `responders`, `teams`, `priority`
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        If `field` is set as extra-properties, key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default: `false`
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class NotificationPolicyTimeRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionList":
            suggest = "restriction_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyTimeRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyTimeRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyTimeRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 restriction: Optional[Sequence['outputs.NotificationPolicyTimeRestrictionRestriction']] = None,
                 restriction_list: Optional[Sequence['outputs.NotificationPolicyTimeRestrictionRestrictionList']] = None):
        """
        :param str type: Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: `time-of-day`, `weekday-and-time-of-day`
        :param Sequence['NotificationPolicyTimeRestrictionRestrictionArgs'] restriction: A definition of hourly definition applied daily, this has to be used with combination: type = `time-of-day`. This is a block, structure is documented below.
        :param Sequence['NotificationPolicyTimeRestrictionRestrictionListArgs'] restriction_list: List of days and hours definitions for field type = `weekday-and-time-of-day`. This is a block, structure is documented below.
        """
        NotificationPolicyTimeRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            restriction=restriction,
            restriction_list=restriction_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             restriction: Optional[Sequence['outputs.NotificationPolicyTimeRestrictionRestriction']] = None,
             restriction_list: Optional[Sequence['outputs.NotificationPolicyTimeRestrictionRestrictionList']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if restriction is not None:
            _setter("restriction", restriction)
        if restriction_list is not None:
            _setter("restriction_list", restriction_list)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines if restriction should apply daily on given hours or on certain days and hours. Possible values are: `time-of-day`, `weekday-and-time-of-day`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restriction(self) -> Optional[Sequence['outputs.NotificationPolicyTimeRestrictionRestriction']]:
        """
        A definition of hourly definition applied daily, this has to be used with combination: type = `time-of-day`. This is a block, structure is documented below.
        """
        return pulumi.get(self, "restriction")

    @property
    @pulumi.getter(name="restrictionList")
    def restriction_list(self) -> Optional[Sequence['outputs.NotificationPolicyTimeRestrictionRestrictionList']]:
        """
        List of days and hours definitions for field type = `weekday-and-time-of-day`. This is a block, structure is documented below.
        """
        return pulumi.get(self, "restriction_list")


@pulumi.output_type
class NotificationPolicyTimeRestrictionRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyTimeRestrictionRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyTimeRestrictionRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyTimeRestrictionRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_hour: int,
                 end_min: int,
                 start_hour: int,
                 start_min: int):
        """
        :param int end_hour: Ending hour of restriction.
        :param int end_min: Ending minute of restriction on defined `end_hour`
        :param int start_hour: Starting hour of restriction.
        :param int start_min: Staring minute of restriction on defined `start_hour`
        """
        NotificationPolicyTimeRestrictionRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_hour=end_hour,
            end_min=end_min,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_hour: int,
             end_min: int,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Ending hour of restriction.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Ending minute of restriction on defined `end_hour`
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Starting hour of restriction.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Staring minute of restriction on defined `start_hour`
        """
        return pulumi.get(self, "start_min")


@pulumi.output_type
class NotificationPolicyTimeRestrictionRestrictionList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDay":
            suggest = "end_day"
        elif key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startDay":
            suggest = "start_day"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyTimeRestrictionRestrictionList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyTimeRestrictionRestrictionList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyTimeRestrictionRestrictionList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        """
        :param str end_day: Ending day of restriction (eg. `wednesday`)
        :param int end_hour: Ending hour of restriction on defined `end_day`
        :param int end_min: Ending minute of restriction on defined `end_hour`
        :param str start_day: Starting day of restriction (eg. `monday`)
        :param int start_hour: Starting hour of restriction on defined `start_day`
        :param int start_min: Staring minute of restriction on defined `start_hour`
        """
        NotificationPolicyTimeRestrictionRestrictionList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_day=end_day,
            end_hour=end_hour,
            end_min=end_min,
            start_day=start_day,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_day: str,
             end_hour: int,
             end_min: int,
             start_day: str,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_day", end_day)
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_day", start_day)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        """
        Ending day of restriction (eg. `wednesday`)
        """
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Ending hour of restriction on defined `end_day`
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Ending minute of restriction on defined `end_hour`
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        """
        Starting day of restriction (eg. `monday`)
        """
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Starting hour of restriction on defined `start_day`
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Staring minute of restriction on defined `start_hour`
        """
        return pulumi.get(self, "start_min")


@pulumi.output_type
class NotificationRuleCriteria(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.NotificationRuleCriteriaCondition']] = None):
        """
        :param str type: Kind of matching filter. Possible values: `match-all`, `match-any-condition`, `match-all-conditions`
        :param Sequence['NotificationRuleCriteriaConditionArgs'] conditions: Defines the fields and values when the condition applies
        """
        NotificationRuleCriteria._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            conditions=conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             conditions: Optional[Sequence['outputs.NotificationRuleCriteriaCondition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if conditions is not None:
            _setter("conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Kind of matching filter. Possible values: `match-all`, `match-any-condition`, `match-all-conditions`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.NotificationRuleCriteriaCondition']]:
        """
        Defines the fields and values when the condition applies
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class NotificationRuleCriteriaCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationRuleCriteriaCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationRuleCriteriaCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationRuleCriteriaCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param str field: Possible values: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`
        :param str operation: Possible values: `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`
        :param str expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param str key: If 'field' is set as 'extra-properties', key could be used for key-value pair
        :param bool not_: Indicates behaviour of the given operation. Default: `false`
        :param int order: Order of the condition in conditions list
        """
        NotificationRuleCriteriaCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Possible values: `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Possible values: `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        If 'field' is set as 'extra-properties', key could be used for key-value pair
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default: `false`
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of the condition in conditions list
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class NotificationRuleRepeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loopAfter":
            suggest = "loop_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationRuleRepeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationRuleRepeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationRuleRepeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loop_after: int,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: If policy should be enabled. Default: `true`
        """
        NotificationRuleRepeat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            loop_after=loop_after,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             loop_after: int,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("loop_after", loop_after)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="loopAfter")
    def loop_after(self) -> int:
        return pulumi.get(self, "loop_after")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If policy should be enabled. Default: `true`
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NotificationRuleSchedule(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the notification policy
        :param str type: Kind of matching filter. Possible values: `match-all`, `match-any-condition`, `match-all-conditions`
        """
        NotificationRuleSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the notification policy
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Kind of matching filter. Possible values: `match-all`, `match-any-condition`, `match-all-conditions`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NotificationRuleStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sendAfter":
            suggest = "send_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationRuleStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationRuleStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationRuleStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contacts: Sequence['outputs.NotificationRuleStepContact'],
                 enabled: Optional[bool] = None,
                 send_after: Optional[int] = None):
        """
        :param Sequence['NotificationRuleStepContactArgs'] contacts: Defines the contact that notification will be sent to. This is a block, structure is documented below.
        :param bool enabled: Defined if this step is enabled. Default: `true`
        :param int send_after: Time period, in minutes, notification will be sent after.
        """
        NotificationRuleStep._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contacts=contacts,
            enabled=enabled,
            send_after=send_after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contacts: Sequence['outputs.NotificationRuleStepContact'],
             enabled: Optional[bool] = None,
             send_after: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("contacts", contacts)
        if enabled is not None:
            _setter("enabled", enabled)
        if send_after is not None:
            _setter("send_after", send_after)

    @property
    @pulumi.getter
    def contacts(self) -> Sequence['outputs.NotificationRuleStepContact']:
        """
        Defines the contact that notification will be sent to. This is a block, structure is documented below.
        """
        return pulumi.get(self, "contacts")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defined if this step is enabled. Default: `true`
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="sendAfter")
    def send_after(self) -> Optional[int]:
        """
        Time period, in minutes, notification will be sent after.
        """
        return pulumi.get(self, "send_after")


@pulumi.output_type
class NotificationRuleStepContact(dict):
    def __init__(__self__, *,
                 method: str,
                 to: str):
        """
        :param str method: Contact method. Possible values: `email`, `sms`, `voice`, `mobile`
        :param str to: Address of a given method (eg. email address for `email`, phone number for `sms`/`voice` or mobile application name for `mobile`)
        """
        NotificationRuleStepContact._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            method=method,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             method: str,
             to: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("method", method)
        _setter("to", to)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Contact method. Possible values: `email`, `sms`, `voice`, `mobile`
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def to(self) -> str:
        """
        Address of a given method (eg. email address for `email`, phone number for `sms`/`voice` or mobile application name for `mobile`)
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class NotificationRuleTimeRestriction(dict):
    def __init__(__self__, *,
                 type: str,
                 restriction: Optional[Sequence['outputs.NotificationRuleTimeRestrictionRestriction']] = None,
                 restrictions: Optional[Sequence['outputs.NotificationRuleTimeRestrictionRestriction']] = None):
        """
        :param str type: Kind of matching filter. Possible values: `match-all`, `match-any-condition`, `match-all-conditions`
        """
        NotificationRuleTimeRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            restriction=restriction,
            restrictions=restrictions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             restriction: Optional[Sequence['outputs.NotificationRuleTimeRestrictionRestriction']] = None,
             restrictions: Optional[Sequence['outputs.NotificationRuleTimeRestrictionRestriction']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if restriction is not None:
            _setter("restriction", restriction)
        if restrictions is not None:
            _setter("restrictions", restrictions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Kind of matching filter. Possible values: `match-all`, `match-any-condition`, `match-all-conditions`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restriction(self) -> Optional[Sequence['outputs.NotificationRuleTimeRestrictionRestriction']]:
        return pulumi.get(self, "restriction")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.NotificationRuleTimeRestrictionRestriction']]:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class NotificationRuleTimeRestrictionRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDay":
            suggest = "end_day"
        elif key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startDay":
            suggest = "start_day"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationRuleTimeRestrictionRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationRuleTimeRestrictionRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationRuleTimeRestrictionRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        NotificationRuleTimeRestrictionRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_day=end_day,
            end_hour=end_hour,
            end_min=end_min,
            start_day=start_day,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_day: str,
             end_hour: int,
             end_min: int,
             start_day: str,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_day", end_day)
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_day", start_day)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        return pulumi.get(self, "start_min")


@pulumi.output_type
class ScheduleRotationParticipant(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str type: The responder type.
        :param str id: The id of the responder.
        """
        ScheduleRotationParticipant._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The responder type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the responder.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ScheduleRotationTimeRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionList":
            suggest = "restriction_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleRotationTimeRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleRotationTimeRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleRotationTimeRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 restriction: Optional[Sequence['outputs.ScheduleRotationTimeRestrictionRestriction']] = None,
                 restriction_list: Optional[Sequence['outputs.ScheduleRotationTimeRestrictionRestrictionList']] = None):
        """
        :param str type: This parameter should be set to `time-of-day` or `weekday-and-time-of-day`.
        :param Sequence['ScheduleRotationTimeRestrictionRestrictionArgs'] restriction: It is a restriction object which is described below. In this case startDay/endDay fields are not supported. This can be used only if time restriction type is `time-of-day`.
        :param Sequence['ScheduleRotationTimeRestrictionRestrictionListArgs'] restriction_list: It is a restriction object which is described below. This can be used only if time restriction type is `weekday-and-time-of-day`.
        """
        ScheduleRotationTimeRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            restriction=restriction,
            restriction_list=restriction_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             restriction: Optional[Sequence['outputs.ScheduleRotationTimeRestrictionRestriction']] = None,
             restriction_list: Optional[Sequence['outputs.ScheduleRotationTimeRestrictionRestrictionList']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if restriction is not None:
            _setter("restriction", restriction)
        if restriction_list is not None:
            _setter("restriction_list", restriction_list)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This parameter should be set to `time-of-day` or `weekday-and-time-of-day`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restriction(self) -> Optional[Sequence['outputs.ScheduleRotationTimeRestrictionRestriction']]:
        """
        It is a restriction object which is described below. In this case startDay/endDay fields are not supported. This can be used only if time restriction type is `time-of-day`.
        """
        return pulumi.get(self, "restriction")

    @property
    @pulumi.getter(name="restrictionList")
    def restriction_list(self) -> Optional[Sequence['outputs.ScheduleRotationTimeRestrictionRestrictionList']]:
        """
        It is a restriction object which is described below. This can be used only if time restriction type is `weekday-and-time-of-day`.
        """
        return pulumi.get(self, "restriction_list")


@pulumi.output_type
class ScheduleRotationTimeRestrictionRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleRotationTimeRestrictionRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleRotationTimeRestrictionRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleRotationTimeRestrictionRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_hour: int,
                 end_min: int,
                 start_hour: int,
                 start_min: int):
        """
        :param int end_hour: Value of the hour that frame will end.
        :param int end_min: Value of the minute that frame will end. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        :param int start_hour: Value of the hour that frame will start.
        :param int start_min: Value of the minute that frame will start. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        ScheduleRotationTimeRestrictionRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_hour=end_hour,
            end_min=end_min,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_hour: int,
             end_min: int,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Value of the hour that frame will end.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Value of the minute that frame will end. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Value of the hour that frame will start.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Value of the minute that frame will start. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        return pulumi.get(self, "start_min")


@pulumi.output_type
class ScheduleRotationTimeRestrictionRestrictionList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDay":
            suggest = "end_day"
        elif key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startDay":
            suggest = "start_day"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleRotationTimeRestrictionRestrictionList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleRotationTimeRestrictionRestrictionList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleRotationTimeRestrictionRestrictionList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        """
        :param str end_day: Value of the day that frame will end.
        :param int end_hour: Value of the hour that frame will end.
        :param int end_min: Value of the minute that frame will end. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
               
               Both `start_day` and `end_day` can assume only `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, or `sunday` values.
        :param str start_day: Value of the day that frame will start.
        :param int start_hour: Value of the hour that frame will start
        :param int start_min: Value of the minute that frame will start. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        ScheduleRotationTimeRestrictionRestrictionList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_day=end_day,
            end_hour=end_hour,
            end_min=end_min,
            start_day=start_day,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_day: str,
             end_hour: int,
             end_min: int,
             start_day: str,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_day", end_day)
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_day", start_day)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        """
        Value of the day that frame will end.
        """
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        """
        Value of the hour that frame will end.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        """
        Value of the minute that frame will end. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.

        Both `start_day` and `end_day` can assume only `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, or `sunday` values.
        """
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        """
        Value of the day that frame will start.
        """
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Value of the hour that frame will start
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        """
        Value of the minute that frame will start. Minutes may take 0 or 30 as value. Otherwise they will be converted to nearest 0 or 30 automatically.
        """
        return pulumi.get(self, "start_min")


@pulumi.output_type
class ServiceIncidentRuleIncidentRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentProperties":
            suggest = "incident_properties"
        elif key == "conditionMatchType":
            suggest = "condition_match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIncidentRuleIncidentRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIncidentRuleIncidentRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIncidentRuleIncidentRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_properties: Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentProperty'],
                 condition_match_type: Optional[str] = None,
                 conditions: Optional[Sequence['outputs.ServiceIncidentRuleIncidentRuleCondition']] = None):
        """
        :param Sequence['ServiceIncidentRuleIncidentRuleIncidentPropertyArgs'] incident_properties: Properties for incident rule. This is a block, structure is documented below.
        :param str condition_match_type: A Condition type, supported types are: `match-all`, `match-any-condition`, `match-all-conditions`. Default: `match-all`
        :param Sequence['ServiceIncidentRuleIncidentRuleConditionArgs'] conditions: Conditions applied to incident. This is a block, structure is documented below.
        """
        ServiceIncidentRuleIncidentRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            incident_properties=incident_properties,
            condition_match_type=condition_match_type,
            conditions=conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             incident_properties: Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentProperty'],
             condition_match_type: Optional[str] = None,
             conditions: Optional[Sequence['outputs.ServiceIncidentRuleIncidentRuleCondition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("incident_properties", incident_properties)
        if condition_match_type is not None:
            _setter("condition_match_type", condition_match_type)
        if conditions is not None:
            _setter("conditions", conditions)

    @property
    @pulumi.getter(name="incidentProperties")
    def incident_properties(self) -> Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentProperty']:
        """
        Properties for incident rule. This is a block, structure is documented below.
        """
        return pulumi.get(self, "incident_properties")

    @property
    @pulumi.getter(name="conditionMatchType")
    def condition_match_type(self) -> Optional[str]:
        """
        A Condition type, supported types are: `match-all`, `match-any-condition`, `match-all-conditions`. Default: `match-all`
        """
        return pulumi.get(self, "condition_match_type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ServiceIncidentRuleIncidentRuleCondition']]:
        """
        Conditions applied to incident. This is a block, structure is documented below.
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceIncidentRuleIncidentRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIncidentRuleIncidentRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIncidentRuleIncidentRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIncidentRuleIncidentRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None):
        """
        :param str field: Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`
        :param str operation: It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        :param str expected_value: User defined value that will be compared with alert field according to the operation. Default: empty string
        :param bool not_: Indicates behaviour of the given operation. Default: false
        """
        ServiceIncidentRuleIncidentRuleCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `details`, `extra-properties`, `recipients`, `teams`, `priority`
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty`, `equals-ignore-whitespace`.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        """
        User defined value that will be compared with alert field according to the operation. Default: empty string
        """
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default: false
        """
        return pulumi.get(self, "not_")


@pulumi.output_type
class ServiceIncidentRuleIncidentRuleIncidentProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stakeholderProperties":
            suggest = "stakeholder_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIncidentRuleIncidentRuleIncidentProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIncidentRuleIncidentRuleIncidentProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIncidentRuleIncidentRuleIncidentProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 priority: str,
                 stakeholder_properties: Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty'],
                 description: Optional[str] = None,
                 details: Optional[Mapping[str, str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param str message: Message of the related incident rule.
        :param str priority: Priority level of the alert. Possible values are `P1`, `P2`, `P3`, `P4` and `P5`
        :param Sequence['ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderPropertyArgs'] stakeholder_properties: DEtails about stakeholders for this rule. This is a block, structure is documented below.
        :param str description: Description field of the incident rule.
        :param Mapping[str, str] details: Map of key-value pairs to use as custom properties of the alert.
        :param Sequence[str] tags: Tags of the alert.
        """
        ServiceIncidentRuleIncidentRuleIncidentProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            priority=priority,
            stakeholder_properties=stakeholder_properties,
            description=description,
            details=details,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: str,
             priority: str,
             stakeholder_properties: Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty'],
             description: Optional[str] = None,
             details: Optional[Mapping[str, str]] = None,
             tags: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("message", message)
        _setter("priority", priority)
        _setter("stakeholder_properties", stakeholder_properties)
        if description is not None:
            _setter("description", description)
        if details is not None:
            _setter("details", details)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message of the related incident rule.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def priority(self) -> str:
        """
        Priority level of the alert. Possible values are `P1`, `P2`, `P3`, `P4` and `P5`
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="stakeholderProperties")
    def stakeholder_properties(self) -> Sequence['outputs.ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty']:
        """
        DEtails about stakeholders for this rule. This is a block, structure is documented below.
        """
        return pulumi.get(self, "stakeholder_properties")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description field of the incident rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[Mapping[str, str]]:
        """
        Map of key-value pairs to use as custom properties of the alert.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags of the alert.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty(dict):
    def __init__(__self__, *,
                 message: str,
                 description: Optional[str] = None,
                 enable: Optional[bool] = None):
        """
        :param str message: Message that is to be passed to audience that is generally used to provide a content information about the alert.
        :param str description: Description that is generally used to provide a detailed information about the alert.
        :param bool enable: Option to enable stakeholder notifications.Default value is true.
        """
        ServiceIncidentRuleIncidentRuleIncidentPropertyStakeholderProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            description=description,
            enable=enable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: str,
             description: Optional[str] = None,
             enable: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("message", message)
        if description is not None:
            _setter("description", description)
        if enable is not None:
            _setter("enable", enable)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message that is to be passed to audience that is generally used to provide a content information about the alert.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description that is generally used to provide a detailed information about the alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Option to enable stakeholder notifications.Default value is true.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class TeamMember(dict):
    def __init__(__self__, *,
                 id: str,
                 role: Optional[str] = None):
        """
        :param str id: The UUID for the member to add to this Team.
        :param str role: The role for the user within the Team - can be either `admin` or `user`. Default: `user`.
        """
        TeamMember._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             role: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if role is not None:
            _setter("role", role)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID for the member to add to this Team.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The role for the user within the Team - can be either `admin` or `user`. Default: `user`.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class TeamRoutingRuleCriteria(dict):
    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.TeamRoutingRuleCriteriaCondition']] = None):
        """
        :param str type: Type of the operation will be applied on conditions. Should be one of `match-all`, `match-any-condition` or `match-all-conditions`.
        :param Sequence['TeamRoutingRuleCriteriaConditionArgs'] conditions: List of conditions will be checked before applying team routing rule. This field declaration should be omitted if the criteria type is set to match-all.
        """
        TeamRoutingRuleCriteria._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            conditions=conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             conditions: Optional[Sequence['outputs.TeamRoutingRuleCriteriaCondition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if conditions is not None:
            _setter("conditions", conditions)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the operation will be applied on conditions. Should be one of `match-all`, `match-any-condition` or `match-all-conditions`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.TeamRoutingRuleCriteriaCondition']]:
        """
        List of conditions will be checked before applying team routing rule. This field declaration should be omitted if the criteria type is set to match-all.
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class TeamRoutingRuleCriteriaCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamRoutingRuleCriteriaCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamRoutingRuleCriteriaCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamRoutingRuleCriteriaCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 operation: str,
                 expected_value: Optional[str] = None,
                 key: Optional[str] = None,
                 not_: Optional[bool] = None,
                 order: Optional[int] = None):
        """
        :param str field: Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `extra-properties`, `recipients`, `teams` or `priority`.
        :param str operation: It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty` and `equals-ignore-whitespace`.
        :param str key: If field is set as extra-properties, key could be used for key-value pair.
        :param bool not_: Indicates behaviour of the given operation. Default value is false.
        :param int order: Order of the condition in conditions list.
        """
        TeamRoutingRuleCriteriaCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operation=operation,
            expected_value=expected_value,
            key=key,
            not_=not_,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             operation: str,
             expected_value: Optional[str] = None,
             key: Optional[str] = None,
             not_: Optional[bool] = None,
             order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("operation", operation)
        if expected_value is not None:
            _setter("expected_value", expected_value)
        if key is not None:
            _setter("key", key)
        if not_ is not None:
            _setter("not_", not_)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Specifies which alert field will be used in condition. Possible values are `message`, `alias`, `description`, `source`, `entity`, `tags`, `actions`, `extra-properties`, `recipients`, `teams` or `priority`.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        It is the operation that will be executed for the given field and key. Possible operations are `matches`, `contains`, `starts-with`, `ends-with`, `equals`, `contains-key`, `contains-value`, `greater-than`, `less-than`, `is-empty` and `equals-ignore-whitespace`.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        If field is set as extra-properties, key could be used for key-value pair.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[bool]:
        """
        Indicates behaviour of the given operation. Default value is false.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of the condition in conditions list.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class TeamRoutingRuleNotify(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        TeamRoutingRuleNotify._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class TeamRoutingRuleTimeRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionList":
            suggest = "restriction_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamRoutingRuleTimeRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamRoutingRuleTimeRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamRoutingRuleTimeRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 restriction: Optional[Sequence['outputs.TeamRoutingRuleTimeRestrictionRestriction']] = None,
                 restriction_list: Optional[Sequence['outputs.TeamRoutingRuleTimeRestrictionRestrictionList']] = None):
        """
        :param str type: Type of the operation will be applied on conditions. Should be one of `match-all`, `match-any-condition` or `match-all-conditions`.
        """
        TeamRoutingRuleTimeRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            restriction=restriction,
            restriction_list=restriction_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             restriction: Optional[Sequence['outputs.TeamRoutingRuleTimeRestrictionRestriction']] = None,
             restriction_list: Optional[Sequence['outputs.TeamRoutingRuleTimeRestrictionRestrictionList']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if restriction is not None:
            _setter("restriction", restriction)
        if restriction_list is not None:
            _setter("restriction_list", restriction_list)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the operation will be applied on conditions. Should be one of `match-all`, `match-any-condition` or `match-all-conditions`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def restriction(self) -> Optional[Sequence['outputs.TeamRoutingRuleTimeRestrictionRestriction']]:
        return pulumi.get(self, "restriction")

    @property
    @pulumi.getter(name="restrictionList")
    def restriction_list(self) -> Optional[Sequence['outputs.TeamRoutingRuleTimeRestrictionRestrictionList']]:
        return pulumi.get(self, "restriction_list")


@pulumi.output_type
class TeamRoutingRuleTimeRestrictionRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamRoutingRuleTimeRestrictionRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamRoutingRuleTimeRestrictionRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamRoutingRuleTimeRestrictionRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_hour: int,
                 end_min: int,
                 start_hour: int,
                 start_min: int):
        TeamRoutingRuleTimeRestrictionRestriction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_hour=end_hour,
            end_min=end_min,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_hour: int,
             end_min: int,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        return pulumi.get(self, "start_min")


@pulumi.output_type
class TeamRoutingRuleTimeRestrictionRestrictionList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDay":
            suggest = "end_day"
        elif key == "endHour":
            suggest = "end_hour"
        elif key == "endMin":
            suggest = "end_min"
        elif key == "startDay":
            suggest = "start_day"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMin":
            suggest = "start_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamRoutingRuleTimeRestrictionRestrictionList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamRoutingRuleTimeRestrictionRestrictionList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamRoutingRuleTimeRestrictionRestrictionList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_day: str,
                 end_hour: int,
                 end_min: int,
                 start_day: str,
                 start_hour: int,
                 start_min: int):
        TeamRoutingRuleTimeRestrictionRestrictionList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_day=end_day,
            end_hour=end_hour,
            end_min=end_min,
            start_day=start_day,
            start_hour=start_hour,
            start_min=start_min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_day: str,
             end_hour: int,
             end_min: int,
             start_day: str,
             start_hour: int,
             start_min: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_day", end_day)
        _setter("end_hour", end_hour)
        _setter("end_min", end_min)
        _setter("start_day", start_day)
        _setter("start_hour", start_hour)
        _setter("start_min", start_min)

    @property
    @pulumi.getter(name="endDay")
    def end_day(self) -> str:
        return pulumi.get(self, "end_day")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMin")
    def end_min(self) -> int:
        return pulumi.get(self, "end_min")

    @property
    @pulumi.getter(name="startDay")
    def start_day(self) -> str:
        return pulumi.get(self, "start_day")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMin")
    def start_min(self) -> int:
        return pulumi.get(self, "start_min")


@pulumi.output_type
class UserUserAddress(dict):
    def __init__(__self__, *,
                 city: str,
                 country: str,
                 line: str,
                 state: str,
                 zipcode: str):
        UserUserAddress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            city=city,
            country=country,
            line=line,
            state=state,
            zipcode=zipcode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             city: str,
             country: str,
             line: str,
             state: str,
             zipcode: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("city", city)
        _setter("country", country)
        _setter("line", line)
        _setter("state", state)
        _setter("zipcode", zipcode)

    @property
    @pulumi.getter
    def city(self) -> str:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> str:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def line(self) -> str:
        return pulumi.get(self, "line")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def zipcode(self) -> str:
        return pulumi.get(self, "zipcode")


@pulumi.output_type
class GetEscalationRepeatResult(dict):
    def __init__(__self__, *,
                 close_alert_after_all: Optional[bool] = None,
                 count: Optional[int] = None,
                 reset_recipient_states: Optional[bool] = None,
                 wait_interval: Optional[int] = None):
        GetEscalationRepeatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            close_alert_after_all=close_alert_after_all,
            count=count,
            reset_recipient_states=reset_recipient_states,
            wait_interval=wait_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             close_alert_after_all: Optional[bool] = None,
             count: Optional[int] = None,
             reset_recipient_states: Optional[bool] = None,
             wait_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if close_alert_after_all is not None:
            _setter("close_alert_after_all", close_alert_after_all)
        if count is not None:
            _setter("count", count)
        if reset_recipient_states is not None:
            _setter("reset_recipient_states", reset_recipient_states)
        if wait_interval is not None:
            _setter("wait_interval", wait_interval)

    @property
    @pulumi.getter(name="closeAlertAfterAll")
    def close_alert_after_all(self) -> Optional[bool]:
        return pulumi.get(self, "close_alert_after_all")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="resetRecipientStates")
    def reset_recipient_states(self) -> Optional[bool]:
        return pulumi.get(self, "reset_recipient_states")

    @property
    @pulumi.getter(name="waitInterval")
    def wait_interval(self) -> Optional[int]:
        return pulumi.get(self, "wait_interval")


@pulumi.output_type
class GetEscalationRuleResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 delay: int,
                 notify_type: str,
                 recipients: Sequence['outputs.GetEscalationRuleRecipientResult']):
        GetEscalationRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            delay=delay,
            notify_type=notify_type,
            recipients=recipients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             delay: int,
             notify_type: str,
             recipients: Sequence['outputs.GetEscalationRuleRecipientResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("condition", condition)
        _setter("delay", delay)
        _setter("notify_type", notify_type)
        _setter("recipients", recipients)

    @property
    @pulumi.getter
    def condition(self) -> str:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def delay(self) -> int:
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> str:
        return pulumi.get(self, "notify_type")

    @property
    @pulumi.getter
    def recipients(self) -> Sequence['outputs.GetEscalationRuleRecipientResult']:
        return pulumi.get(self, "recipients")


@pulumi.output_type
class GetEscalationRuleRecipientResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Escalation.
        """
        GetEscalationRuleRecipientResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Escalation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTeamMemberResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 role: Optional[str] = None):
        """
        :param str id: The ID of the Opsgenie Team.
        """
        GetTeamMemberResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             role: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if role is not None:
            _setter("role", role)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Opsgenie Team.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")


